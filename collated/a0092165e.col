//@author: a0092165e



	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\parser\ExtractorTest.java
	 */

package whatsupnext.junit.parser;

import static org.junit.Assert.*;

import java.util.Calendar;

import org.junit.Test;

import whatsupnext.parser.extractor.AddExtractor;
import whatsupnext.parser.extractor.DeleteExtractor;
import whatsupnext.parser.extractor.DoneExtractor;
import whatsupnext.parser.extractor.FreeExtractor;
import whatsupnext.parser.extractor.HelpExtractor;
import whatsupnext.parser.extractor.SearchExtractor;
import whatsupnext.parser.extractor.UpdateExtractor;
import whatsupnext.parser.extractor.ViewExtractor;
import whatsupnext.structure.enums.Types.ADDTYPE;
import whatsupnext.structure.enums.Types.DELETETYPE;
import whatsupnext.structure.enums.Types.FREETYPE;
import whatsupnext.structure.enums.Types.UPDATETYPE;
import whatsupnext.structure.enums.Types.VIEWTYPE;
import whatsupnext.structure.util.Help;
import whatsupnext.structure.util.Task;

public class ExtractorTest {
	
	private String getTomorrowDate() {
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DAY_OF_YEAR, 1);
		String year = Integer.toString(cal.get(Calendar.YEAR));
		String twoDigitMonth = convertToTwoDigits(cal.get(Calendar.MONTH) + 1);
		String twoDigitDayOfMonth = convertToTwoDigits(cal.get(Calendar.DAY_OF_MONTH));  
         
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	public String getTodayDate() {
		Calendar cal = Calendar.getInstance();
		String year = Integer.toString(cal.get(Calendar.YEAR));
		String twoDigitMonth = convertToTwoDigits(cal.get(Calendar.MONTH) + 1);
		String twoDigitDayOfMonth = convertToTwoDigits(cal.get(Calendar.DAY_OF_MONTH));     
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	public String getTodayDateTime() {
		Calendar cal = Calendar.getInstance();
		String year = Integer.toString(cal.get(Calendar.YEAR));
		String twoDigitMonth = convertToTwoDigits(cal.get(Calendar.MONTH) + 1);
		String twoDigitDayOfMonth = convertToTwoDigits(cal.get(Calendar.DAY_OF_MONTH));
		String twoDigitHour = convertToTwoDigits(cal.get(Calendar.HOUR_OF_DAY));
		String twoDigitMinute = convertToTwoDigits(cal.get(Calendar.MINUTE));
		return year + twoDigitMonth + twoDigitDayOfMonth + twoDigitHour + twoDigitMinute;
	}
	
	private String convertToTwoDigits(int possibleSingleDigit) {
		if (possibleSingleDigit < 10) {
        	return "0" + possibleSingleDigit;
		} else {
			return "" + possibleSingleDigit;
		}
	}
	
	@Test
	/* This test case combines 2 valid dates*/
	public void testAdd() {
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		ex.extract(task, "dine from 1800 tml to 2200 tml");
		assertEquals("Test Add - description", "dine", task.getDescription());
		assertEquals("Test Add - startTime", getTomorrowDate()+"1800", task.getStartTime());
		assertEquals("Test Add - endTime", getTomorrowDate()+"2200", task.getEndTime());
		assertEquals("Test Add - addType",ADDTYPE.TIMEFRAME,task.getAddType());
	}
	
	@Test
	/* This test case is equivalent partitioning of add by deadline only*/
	public void testAdd2() {
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		ex.extract(task, "dine By 13:00 tml");
		assertEquals("Test Add - description", "dine", task.getDescription());
		assertEquals("Test Add - startTime", "", task.getStartTime());
		assertEquals("Test Add - endTime", getTomorrowDate() + "1300", task.getEndTime());
		assertEquals("Test Add - addType", ADDTYPE.DEADLINE,task.getAddType());
	}
	
	
	@Test
	/* This test case is extreme case where description contains keyword by*/
	public void testAdd3() {
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		ex.extract(task, "dine in restaurant by the river By 13:00 tml");
		assertEquals("Test Add - description", "dine in restaurant by the river", task.getDescription());
		assertEquals("Test Add - startTime", "", task.getStartTime());
		assertEquals("Test Add - endTime", getTomorrowDate() + "1300", task.getEndTime());
		assertEquals("Test Add - addType", ADDTYPE.DEADLINE,task.getAddType());
	}
	
	
	@Test
	/* testing invalid case one by one*/
	public void testAddInvalidDescription() {
		String MESSAGE_INVALID_DESCRIPTION = "'add' must have a valid description";
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		try{
			ex.extract(task, "By 13:00");
		} catch (Exception e) {
			assertEquals("Test invalid description", MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
		try{
			ex.extract(task, "");
		} catch (Exception e) {
			assertEquals("Test invalid description", MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
		try{
			ex.extract(task, "from 1234 to 1235");
		} catch (Exception e) {
			assertEquals("Test invalid description", MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
		
	}

	@Test
	/* testing invalid case one by one*/
	public void testAddInvalidEndTime() {
		String MESSAGE_INVALID_END_TIME = "'add' must have a valid end time";
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		try{
			ex.extract(task, "test By rubbish");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
		try{
			ex.extract(task, "test by 231014");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
		try{
			ex.extract(task, "test from 2359 today to 231014");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testAddInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'add' must have a valid start time";
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		try{
			ex.extract(task, "test from rubbish to 1234");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_START_TIME, e.getMessage());
		}
		try{
			ex.extract(task, "test from rubbish to time");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_START_TIME, e.getMessage());
		}
		try{
			ex.extract(task, "test from 231014 to tml");
			System.out.println(task.getStartTime());
		} catch (Exception e) {
			assertEquals("Test invalid start time", MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testAddInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		try{
			ex.extract(task, "get up from 2359 tml to 2358 tml");
		} catch (Exception e) {
			assertEquals("Test invalid start end time", MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}	
	}
	
	@Test
	/* testing for delete ID case:equivalent partitioning*/
	public void testDelete1() {
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		ex.extract(task, "1");
		assertEquals("Test Delete - ID", "1", task.getTaskID());
		assertEquals("Test Delete - startTime", "", task.getStartTime());
		assertEquals("Test Delete - endTime", "", task.getEndTime());
		assertEquals("Test Delete - deleteType", DELETETYPE.ID, task.getDeleteType());
	}
	
	@Test
	/* testing for delete by endtime case:equivalent partitioning*/
	public void testDelete2() {
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		ex.extract(task, "23:59 101014");
		assertEquals("Test Delete - description", "", task.getDescription());
		assertEquals("Test Delete - startTime", "", task.getStartTime());
		assertEquals("Test Delete - endTime", "201410102359", task.getEndTime());
		assertEquals("Test Delete - deleteType", DELETETYPE.DATE, task.getDeleteType());
	}
	
	@Test
	/* testing for delete deadline case:equivalent partitioning*/
	public void testDelete3() {
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		ex.extract(task, "Deadline");
		assertEquals("Test Delete - description", "", task.getDescription());
		assertEquals("Test Delete - startTime", "", task.getStartTime());
		assertEquals("Test Delete - endTime", getTodayDateTime(), task.getEndTime());
		assertEquals("Test Delete - deleteType", DELETETYPE.DEADLINE, task.getDeleteType());
	}
	
	@Test
	/* testing for delete time frame case:equivalent partitioning*/
	public void testDelete4() {
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		ex.extract(task, "from 00:00 061014 to 23:59 101014");
		assertEquals("Test Delete - description", "", task.getDescription());
		assertEquals("Test Delete - startTime", "201410060000", task.getStartTime());
		assertEquals("Test Delete - endTime", "201410102359", task.getEndTime());
		assertEquals("Test Delete - deleteType", DELETETYPE.TIMEFRAME, task.getDeleteType());
	}
	
	@Test
	/* testing for delete DONE*/
	public void testDelete5() {
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		ex.extract(task, "done");
		assertEquals("Test Delete - deleteType", DELETETYPE.DONE, task.getDeleteType());
	}
	
	@Test
	public void testDeleteInvalidArgument() {
		String MESSAGE_INVALID_ARGUMENT = "'delete' must have an argument";
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		try{
			ex.extract(task, "");
		} catch (Exception e) {
			assertEquals("Test invalid argument", MESSAGE_INVALID_ARGUMENT, e.getMessage());
		}
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testDeleteInvalidTaskIDOrDate() {
		String MESSAGE_INVALID_TASKID_OR_DATE = "'delete' must have a valid Task ID or Date";
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		try{
			ex.extract(task, "ID");
		} catch (Exception e) {
			assertEquals("Test invalid task ID", MESSAGE_INVALID_TASKID_OR_DATE, e.getMessage());
		}
		try{
			ex.extract(task, "-1");
		} catch (Exception e) {
			assertEquals("Test invalid task ID", MESSAGE_INVALID_TASKID_OR_DATE, e.getMessage());
		}
		try{
			ex.extract(task, "2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid time", MESSAGE_INVALID_TASKID_OR_DATE, e.getMessage());
		}
	}
	
	@Test
	public void testDeleteInvalidEndTime() {
		String MESSAGE_INVALID_END_TIME = "'delete' must have an valid end time";
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		try{
			ex.extract(task, "from 1234 to 2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	public void testDeleteInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'delete' must have an valid start time";
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		try{
			ex.extract(task, "from 2014/12/12 to 2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid start time", MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testDeleteInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		Task task = new Task();
		DeleteExtractor ex = new DeleteExtractor();
		try{
			ex.extract(task, "from 0800 to 0100");
		} catch (Exception e) {
			assertEquals("Test invalid start end time", MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}	
	}
	
	@Test
	public void testUpdate1() {
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		ex.extract(task, "10 new description");
		assertEquals("Test Update - description", "new description", task.getDescription());
		assertEquals("Test Update - startTime", "", task.getStartTime());
		assertEquals("Test Update - endTime", "", task.getEndTime());
		assertEquals("Test Update - updateType", UPDATETYPE.DESCRIPTION, task.getUpdateType());
		assertEquals("Test Update - taskID", "10", task.getTaskID());
	}
	
	@Test
	public void testUpdate2() {
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		ex.extract(task, "10 by 1400 tml");
		assertEquals("Test Update - description", "", task.getDescription());
		assertEquals("Test Update - startTime", "", task.getStartTime());
		assertEquals("Test Update - endTime", getTomorrowDate()+"1400", task.getEndTime());
		assertEquals("Test Update - updateType", UPDATETYPE.DEADLINE, task.getUpdateType());
		assertEquals("Test Update - taskID", "10", task.getTaskID());
	}
	
	@Test
	public void testUpdate3() {
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		ex.extract(task, "10 from 00:00 tml to tml");
		assertEquals("Test Update - description", "", task.getDescription());
		assertEquals("Test Update - startTime", getTomorrowDate()+"0000", task.getStartTime());
		assertEquals("Test Update - endTime", getTomorrowDate()+"2359", task.getEndTime());
		assertEquals("Test Update - updateType", UPDATETYPE.TIMEFRAME, task.getUpdateType());
		assertEquals("Test Update - taskID", "10", task.getTaskID());
	}
	
	@Test
	public void testUpdateInvalidTaskID() {
		String MESSAGE_INVALID_TASKID = "'update' must have a valid Task ID";
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		try{
			ex.extract(task, "ID by 1400 061014");
		} catch (Exception e) {
			assertEquals("Test invalid task ID", MESSAGE_INVALID_TASKID, e.getMessage());
		}
		try{
			ex.extract(task, "-1 by 1400 061014");
		} catch (Exception e) {
			assertEquals("Test invalid task ID", MESSAGE_INVALID_TASKID, e.getMessage());
		}
	}

	@Test
	public void testUpdateInvalidDescription() {
		String MESSAGE_INVALID_DESCRIPTION = "'update' must have an valid description";
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		try{
			ex.extract(task, "14 update Desc");
		} catch (Exception e) {
			assertEquals("Test invalid time", MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
	}
	
	@Test
	public void testUpdateInvalidEndTime() {
		String MESSAGE_INVALID_END_TIME = "'update' must have a valid end time";
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		try{
			ex.extract(task, "14 by 2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
		try{
			ex.extract(task, "14 from 1234 tml to 2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	public void testUpdateInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'update' must have a valid start time";
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		try{
			ex.extract(task, "14 from 2014/12/12 to 2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid start time", MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testUpdateInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		Task task = new Task();
		UpdateExtractor ex = new UpdateExtractor();
		try{
			ex.extract(task, "14 from 0800 tml to 0100 tml");
		} catch (Exception e) {
			assertEquals("Test invalid start end time", MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}	
	}
		
	@Test
	public void testViewAll() {
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		ex.extract(task, "all");
		assertEquals("Test View - description", "", task.getDescription());
		assertEquals("Test View - startTime", "", task.getStartTime());
		assertEquals("Test View - endTime", "", task.getEndTime());
		assertEquals("Test View - viewType", VIEWTYPE.ALL, task.getViewType());
	}
	
	@Test
	public void testViewNext() {
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		ex.extract(task, "next");
		assertEquals("Test View - description", "", task.getDescription());
		assertEquals("Test View - startTime", "", task.getStartTime());
		assertEquals("Test View - endTime", getTodayDateTime(), task.getEndTime());
		assertEquals("Test View - viewType", VIEWTYPE.NEXT, task.getViewType());
	}
	
	@Test
	public void testViewDate() {
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		ex.extract(task, "101014");
		assertEquals("Test View - description", "", task.getDescription());
		assertEquals("Test View - startTime", "", task.getStartTime());
		assertEquals("Test View - endTime", "201410102359", task.getEndTime());
		assertEquals("Test View - viewType", VIEWTYPE.DATE, task.getViewType());
	}
	
	@Test
	public void testViewTimeFrame() {
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		ex.extract(task, "from 05102014 to 20:00 101014");
		assertEquals("Test View - description", "", task.getDescription());
		assertEquals("Test View - startTime", "201410050000", task.getStartTime());
		assertEquals("Test View - endTime", "201410102000", task.getEndTime());
		assertEquals("Test View - viewType", VIEWTYPE.TIMEFRAME, task.getViewType());
	}
	
	@Test
	public void testDone() {
		Task task = new Task();
		DoneExtractor ex = new DoneExtractor();
		ex.extract(task, "10");
		assertEquals("Test Done - description", "", task.getDescription());
		assertEquals("Test Done - startTime", "", task.getStartTime());
		assertEquals("Test Done - endTime", "", task.getEndTime());
		assertEquals("Test Done - taskID", "10", task.getTaskID());
	}
	
	@Test
	public void testSearch() {
		Task task = new Task();
		SearchExtractor ex = new SearchExtractor();
		ex.extract(task, "FYP presentation");
		assertEquals("Test Done - description", "FYP presentation", task.getDescription());
		assertEquals("Test Done - startTime", "", task.getStartTime());
		assertEquals("Test Done - endTime", "", task.getEndTime());
		assertEquals("Test Done - taskID", "", task.getTaskID());
	}

	
	@Test
	public void testFree1(){
		Task task = new Task();
		FreeExtractor ex = new FreeExtractor();
		ex.extract(task,"3");
		assertEquals("Test Free - description", "3", task.getDescription());
		assertEquals("Test Free - startTime","", task.getStartTime());
		assertEquals("Test Free - endTime", getTodayDate()+"2359", task.getEndTime());
		assertEquals("Test Free - taskID", "", task.getTaskID());
		assertEquals("Test Free - FREETYPE",FREETYPE.DATE,task.getFreeType());
	}
	
	@Test
	public void testFree2(){
		Task task = new Task();
		FreeExtractor ex = new FreeExtractor();
		ex.extract(task,"3 from 11/11/2014 1000 to 11/11/2014");
		assertEquals("Test Free - description", "3", task.getDescription());
		assertEquals("Test Free - startTime", "201411111000", task.getStartTime());
		assertEquals("Test Free - endTime", "201411112359", task.getEndTime());
		assertEquals("Test Free - taskID", "", task.getTaskID());
		assertEquals("Test Free - FREETYPE",FREETYPE.TIMEFRAME,task.getFreeType());
	}
	
	@Test
	public void testFree3(){
		Task task = new Task();
		FreeExtractor ex = new FreeExtractor();
		ex.extract(task,"3 on 11/11/2014");
		assertEquals("Test Free - description", "3", task.getDescription());
		assertEquals("Test Free - startTime", "", task.getStartTime());
		assertEquals("Test Free - endTime", "201411112359", task.getEndTime());
		assertEquals("Test Free - taskID", "", task.getTaskID());
		assertEquals("Test Free - FREETYPE",FREETYPE.DATE,task.getFreeType());
	}
	
	@Test
	public void testFree4(){
		Task task = new Task();
		FreeExtractor ex = new FreeExtractor();
		ex.extract(task,"3 by 11/11/2014");
		assertEquals("Test Free - description", "3", task.getDescription());
		assertEquals("Test Free - startTime", getTodayDateTime(), task.getStartTime());
		assertEquals("Test Free - endTime", "201411112359", task.getEndTime());
		assertEquals("Test Free - taskID", "", task.getTaskID());
		assertEquals("Test Free - FREETYPE",FREETYPE.TIMEFRAME,task.getFreeType());
	}
	
	@Test
	public void testFreeInvalidDuration(){
		String MESSAGE_INVALID_DURATION = "'free' must have a valid duration: # of hours";
		Task task = new Task();
		FreeExtractor ex = new FreeExtractor();
		try{
			ex.extract(task, "hours");
		} catch (Exception e) {
			assertEquals("Test free - invalid duration", MESSAGE_INVALID_DURATION, e.getMessage());
		}
	}
	
	
	@Test
	public void testViewInvalidArgument() {
		String MESSAGE_INVALID_ARGUMENT = "'view' must have an arguement";
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		try{
			ex.extract(task, "");
		} catch (Exception e) {
			assertEquals("Test invalid argument", MESSAGE_INVALID_ARGUMENT, e.getMessage());
		}
	}

	@Test
	public void testViewInvalidEndTime() {
		String MESSAGE_INVALID_END_TIME = "'view' must have an valid end time";
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		try{
			ex.extract(task, "from 1234 to 2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid end time", MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	public void testViewInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'view' must have an valid start time";
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		try{
			ex.extract(task, "from 2014/12/12 to 1234");
		} catch (Exception e) {
			assertEquals("Test invalid start time", MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	public void testViewInvalidDate() {
		String MESSAGE_INVALID_DATE = "'view' must have an valid date";
		Task task = new Task();
		AddExtractor ex = new AddExtractor();
		try{
			ex.extract(task, "2014/12/12");
		} catch (Exception e) {
			assertEquals("Test invalid time", MESSAGE_INVALID_DATE, e.getMessage());
		}
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testViewInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		Task task = new Task();
		ViewExtractor ex = new ViewExtractor();
		try{
			ex.extract(task, "from 0800 to 0100");
		} catch (Exception e) {
			assertEquals("Test invalid start end time", MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}	
	}
	
	@Test
	/* This test case is equivalent partitioning of help default*/
	public void testHelpDefault() {
		Task task = new Task();
		HelpExtractor ex = new HelpExtractor();
		ex.extract(task, "");
		assertEquals("Help Message", Help.DEFAULT_HELP_MESSAGE, task.getHelpMessage());
	}
	
	@Test
	/* This test case is equivalent partitioning of help detailed*/
	public void testHelpDetailed() {
		Task task = new Task();
		HelpExtractor ex = new HelpExtractor();
		ex.extract(task, "add");
		assertEquals("Help Message", Help.ADD_HELP_MESSAGE, task.getHelpMessage());
	}
	
	@Test
	/* testing invalid case one by one*/
	public void testHelpInvalid() {
		String MESSAGE_INVALID_ARGUMENT = "Invalid Argument.";
		Task task = new Task();
		HelpExtractor ex = new HelpExtractor();
		try{
			ex.extract(task, "invalid verbose");
		} catch (Exception e) {
			assertEquals("Invalid Arguement", MESSAGE_INVALID_ARGUMENT, e.getMessage());
		}	
	}
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\parser\ExtractorTest.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\AddExtractor.java
	 */

package whatsupnext.parser.extractor;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import whatsupnext.structure.enums.Types.ADDTYPE;
import whatsupnext.structure.util.Task;

public class AddExtractor implements Extractor {
		
	private static final Logger log = Logger.getLogger( AddExtractor.class.getName() );
	
	private final String MESSAGE_INVALID_DESCRIPTION = "'add' must have a valid description";
	private final String MESSAGE_INVALID_END_TIME = "'add' must have a valid end time";
	private final String MESSAGE_INVALID_START_TIME = "'add' must have a valid start time";
	private final String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
	
	private ParseDate parseDate;
	
	public AddExtractor(){
		this.parseDate = new ParseDate();
	}
	
	public void extract(Task task, String input){
		assert task != null;
		// Determine 'add' case: add by deadline or time frame
		Pattern byKeywordPattern = Pattern.compile("\\s+(B|b)(Y|y)\\s+");
		Pattern fromKeywordPattern = Pattern.compile("\\s+(F|f)(R|r)(O|o)(M|m)\\s+");
		Matcher byKeywordMatcher = byKeywordPattern.matcher(input);
		Matcher fromKeywordMatcher = fromKeywordPattern.matcher(input);

		if (byKeywordMatcher.find()) {
			task.setAddType(ADDTYPE.DEADLINE);
			splitOnByKeyword(task, input);
		} else if (fromKeywordMatcher.find()) {
			task.setAddType(ADDTYPE.TIMEFRAME);
			splitOnFromToKeyword(task, input);
		} else {
			task.setAddType(ADDTYPE.FLOATING);
			task.setDescription(input);
			if(task.getDescription().isEmpty() 
					|| task.getDescription().matches(".*(B|b)(Y|y).*") 
					|| task.getDescription().matches(".*(F|f)(R|r)(O|o)(M|m).*")){
				throw new IllegalArgumentException(MESSAGE_INVALID_DESCRIPTION);
			}
		}	
	
	}

	/**
	 * Splits the input based on keyword "from" and "to"
	 * 
	 * @param taskDetail
	 */
	private void splitOnFromToKeyword(Task task, String taskDetail) {
		String[] details = taskDetail.split("\\s+(F|f)(R|r)(O|o)(M|m)\\s+");
		task.setDescription(details[0]);
		if(task.getDescription().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_DESCRIPTION);
		}
		String detailsTime = details[1];
		String[] detailsTimeStartAndEnd = detailsTime.split("\\s+(T|t)(O|o)\\s+");
		if(detailsTimeStartAndEnd.length == 1) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		parseDate.setParsingStartTime(true);
		task.setStartTime(parseDate.parseInput(detailsTimeStartAndEnd[0]));
		if(task.getStartTime().isEmpty() 
				|| task.getStartTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_TIME);
		}
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.parseInput(detailsTimeStartAndEnd[1]));
		if(task.getEndTime().isEmpty() 
				|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		if (task.getStartTime().compareTo(task.getEndTime())>0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_END_TIME);
		}
	}

	/**
	 * Splits input based on keyword "by"
	 * @param taskDetails
	 * @return
	 */
	private void splitOnByKeyword(Task task, String taskDetails) {
		String[] details = taskDetails.split("\\s+(B|b)(Y|y)\\s+");
		int detailsSize = details.length;
		if (detailsSize==2) {
			task.setDescription(details[0]);
		    task.setEndTime(parseDate.parseInput(details[1]));
		} else {
			log.setLevel(Level.INFO);
		    log.info("description contains keyword by");
			task.setDescription(Utility.recoverDetails("by",details));
			task.setEndTime(parseDate.parseInput(details[detailsSize-1]));
		}
		if(task.getEndTime().isEmpty() 
				|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
	}

	

	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\AddExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\DeleteExtractor.java
	 */

package whatsupnext.parser.extractor;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import whatsupnext.structure.enums.Types.DELETETYPE;
import whatsupnext.structure.util.Task;

public class DeleteExtractor implements Extractor {
	
	private final String MESSAGE_INVALID_ARGUMENT = "'delete' must have an argument";
	private final String MESSAGE_INVALID_TASKID_OR_DATE = "'delete' must have a valid Task ID or Date";
	private final String MESSAGE_INVALID_END_TIME = "'delete' must have an valid end time";
	private final String MESSAGE_INVALID_START_TIME = "'delete' must have an valid start time";
	private final String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
	
	private ParseDate parseDate;
	
	public DeleteExtractor(){
		this.parseDate = new ParseDate();
	}
	
	public void extract(Task task, String input){
		int numOfWord = Utility.countWords(input);
		if (numOfWord == 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_ARGUMENT);
		} else if (numOfWord == 1) {
			// check if input string is formatted date
		    String formattedDate = parseDate.parseInput(input);
		    if (input.equalsIgnoreCase("deadline")) {
				deleteCaseDeadline(task);
			} else if(input.equalsIgnoreCase("done")) {
				deleteCaseDone(task);
			} else {
				if (formattedDate.isEmpty()) {
					// TODO; should judge for valid ID instead of valid date	
					deleteCaseID(task,input);
				} else{
					deleteCaseDate(task,input);
				}
			}
		    
		} else {
	        Pattern fromKeywordPattern = Pattern.compile("(F|f)(R|r)(O|o)(M|m)\\s+");
	        Matcher fromKeywordMatcher = fromKeywordPattern.matcher(input);
	        if (fromKeywordMatcher.find()) {
	        	deleteCaseTimeFrame(task,input);
	        } else {
	        	deleteCaseDate(task,input);
	        }
		}
	}
	
	
	/**
	 * Delete done tasks
	 * @param task
	 */
	private void deleteCaseDone(Task task) {
		task.setDeleteType(DELETETYPE.DONE);
	}

	/**
	 * Delete by ID. delete detail should be valid task ID
	 * @param task
	 * @param deleteDetail
	 */
	private void deleteCaseID(Task task,String deleteDetail) {
		task.setDeleteType(DELETETYPE.ID);
		try {
			if(Integer.parseInt(deleteDetail) < 0) {
				throw new IllegalArgumentException(MESSAGE_INVALID_TASKID_OR_DATE) ;
			}
			task.setTaskID(deleteDetail);
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_TASKID_OR_DATE);
		}
	}

	/**
	 * Delete by Date
	 * @param task
	 * @param deleteDetail
	 */
	private void deleteCaseDate(Task task,String deleteDetail) {
		task.setDeleteType(DELETETYPE.DATE);
		task.setEndTime(parseDate.parseInput(deleteDetail));
		if (task.getEndTime().isEmpty()){
			 throw new IllegalArgumentException(MESSAGE_INVALID_TASKID_OR_DATE );
		}
	}

	/**
	 * Delete by Deadline
	 * @param task
	 */
	private void deleteCaseDeadline(Task task) {
		task.setDeleteType(DELETETYPE.DEADLINE);
		task.setEndTime(parseDate.getCurrentTime());		
	}
	
	/**
	 * Delete by Time frame
	 * @param task
	 * @param deleteDetail
	 */
	private void deleteCaseTimeFrame(Task task,String deleteDetail) {
		task.setDeleteType(DELETETYPE.TIMEFRAME);
		splitOnToKeyword(task,deleteDetail);
	}

	
	/**
	 * For Delete 
	 * Splits input based on keyword "to"
	 * @param taskDetails
	 * @return
	 */
	private void splitOnToKeyword(Task task,String taskDetails) {
		// Remove "from"
		taskDetails = Utility.removeFirstWord(taskDetails);
		String[] details = taskDetails.split("\\s+(T|t)(O|o)\\s+");
		parseDate.setParsingStartTime(true);
		task.setStartTime(parseDate.parseInput(details[0]));
		if (task.getStartTime().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_START_TIME);
		}
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.parseInput(details[1]));
		if (task.getEndTime().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		if (task.getStartTime().compareTo(task.getEndTime())>0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_END_TIME);
		}
	}
	

	

	
}


	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\DeleteExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\DoneExtractor.java
	 */

package whatsupnext.parser.extractor;

import whatsupnext.structure.util.Task;

public class DoneExtractor implements Extractor{
	private final String MESSAGE_INVALID_TASKID = "'Done' must have a valid ID";
	
	public void extract(Task task, String input){
		try {
			String taskID = Utility.getFirstWord(input);
			if(Integer.parseInt(taskID) < 0 ){
				throw new IllegalArgumentException(MESSAGE_INVALID_TASKID);
			}
			task.setTaskID(taskID);
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_TASKID);
		}	
	}
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\DoneExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\FreeExtractor.java
	 */

package whatsupnext.parser.extractor;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import whatsupnext.structure.enums.Types.FREETYPE;
import whatsupnext.structure.util.Task;

public class FreeExtractor implements Extractor {
	
	private final String MESSAGE_INVALID_DURATION = "'free' must have a valid duration: # of hours";
	private final String MESSAGE_INVALID_END_TIME = "'free' must have a valid end time";
	private final String MESSAGE_INVALID_START_TIME = "'free' must have a valid start time";
	private final String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
	
	private ParseDate parseDate;
	
	public FreeExtractor(){
		this.parseDate = new ParseDate();
	}
	
	
	public void extract(Task task, String input){
		
		assert task != null;
		
		Pattern onKeywordPattern = Pattern.compile("\\s+(O|o)(N|n)\\s+");
		Pattern byKeywordPattern = Pattern.compile("\\s+(B|b)(Y|y)\\s+");
		Pattern fromKeywordPattern = Pattern.compile("\\s+(F|f)(R|r)(O|o)(M|m)\\s+");
		Matcher onKeywordMatcher = onKeywordPattern.matcher(input);
		Matcher byKeywordMatcher = byKeywordPattern.matcher(input);
		Matcher fromKeywordMatcher = fromKeywordPattern.matcher(input);

		if (onKeywordMatcher.find()) {
			task.setFreeType(FREETYPE.DATE);
			splitOnOnKeyword(task, input);
		} else if(byKeywordMatcher.find()){
			task.setFreeType(FREETYPE.TIMEFRAME);
			splitOnByKeyword(task, input);
		} else if (fromKeywordMatcher.find()) {
			task.setFreeType(FREETYPE.TIMEFRAME);
			splitOnFromToKeyword(task, input);
		} else {
			task.setFreeType(FREETYPE.DATE);
			getFreeTimeToday(task,input);
		}	
	
	}

	
	/**
	 * Find free time slots today
	 * @param task
	 * @param input
	 */
	private void getFreeTimeToday(Task task, String input) {
		try {
			if(Integer.parseInt(input) < 0) {
				throw new IllegalArgumentException(MESSAGE_INVALID_DURATION) ;
			}
			task.setDescription(input);
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_DURATION);
		}
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.getTodayDate()+"2359");
	}

	
	/**
	 * Splits the input based on keyword "from" and "to"
	 * @param taskDetail
	 */
	private void splitOnFromToKeyword(Task task, String taskDetail) {
		String[] details = taskDetail.split("\\s+(F|f)(R|r)(O|o)(M|m)\\s+");
		task.setDescription(details[0]);
		if(task.getDescription().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_DURATION);
		}
		try {
			if(Integer.parseInt(task.getDescription()) < 0) {
				throw new IllegalArgumentException(MESSAGE_INVALID_DURATION) ;
			}
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_DURATION);
		}
		
		String detailsTime = details[1];
		String[] detailsTimeStartAndEnd = detailsTime.split("\\s+(T|t)(O|o)\\s+");
		if(detailsTimeStartAndEnd.length == 1) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		parseDate.setParsingStartTime(true);
		task.setStartTime(parseDate.parseInput(detailsTimeStartAndEnd[0]));
		if(task.getStartTime().isEmpty() 
				|| task.getStartTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_TIME);
		}
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.parseInput(detailsTimeStartAndEnd[1]));
		if(task.getEndTime().isEmpty() 
				|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		if (task.getStartTime().compareTo(task.getEndTime())>0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_END_TIME);
		}
	}

	/**
	 * Splits input based on keyword "on"
	 * @param taskDetails
	 * @return
	 */
	private void splitOnOnKeyword(Task task, String taskDetails) {
		String[] details = taskDetails.split("\\s+(O|o)(N|n)\\s+");
		parseDate.setParsingStartTime(false);
		task.setDescription(details[0]);
		try {
			if(Integer.parseInt(task.getDescription()) < 0) {
				throw new IllegalArgumentException(MESSAGE_INVALID_DURATION) ;
			}
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_DURATION);
		}
		
		task.setEndTime(parseDate.parseInput(details[1]));
		if(task.getEndTime().isEmpty() 
				|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
	}

	
	/**
	 * Splits input based on keyword "by"
	 * @param taskDetails
	 * @return
	 */
	private void splitOnByKeyword(Task task, String taskDetails) {
		String[] details = taskDetails.split("\\s+(B|b)(Y|y)\\s+");
		task.setDescription(details[0]);
		try {
			if(Integer.parseInt(task.getDescription()) < 0) {
				throw new IllegalArgumentException(MESSAGE_INVALID_DURATION) ;
			}
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_DURATION);
		}
		task.setStartTime(parseDate.getCurrentTime());
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.parseInput(details[1]));
		if(task.getEndTime().isEmpty() 
				|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
	}
	

	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\FreeExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\SearchExtractor.java
	 */

package whatsupnext.parser.extractor;

import whatsupnext.structure.util.Task;

public class SearchExtractor implements Extractor{

	private final String MESSAGE_INVALID_DESCRIPTION = "'Search' must have valid keywords";
	
	public void extract(Task task, String input){
		String keywords = input;

		if (keywords.trim().equals("")){
			throw new IllegalArgumentException(MESSAGE_INVALID_DESCRIPTION); 
		} else {
			task.setSearchKeyword(keywords);
		}
			
	}
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\SearchExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\UpdateExtractor.java
	 */

package whatsupnext.parser.extractor;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import whatsupnext.structure.enums.Types.UPDATETYPE;
import whatsupnext.structure.util.Task;

public class UpdateExtractor implements Extractor {
	
	private final String MESSAGE_INVALID_TASKID = "'update' must have a valid Task ID";
	private final String MESSAGE_INVALID_DESCRIPTION = "'update' must have a valid description";
	private final String MESSAGE_INVALID_END_TIME = "'update' must have a valid end time";
	private final String MESSAGE_INVALID_START_TIME = "'update' must have a valid start time";
	private final String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
	
	private ParseDate parseDate;
	
	public UpdateExtractor(){
		this.parseDate = new ParseDate();
	}
	
	public void extract(Task task, String input){

		// Get the task ID and remove it from the remaining details
		try {
			String taskID = Utility.getFirstWord(input);
			if(Integer.parseInt(taskID) < 0 ){
				throw new IllegalArgumentException(MESSAGE_INVALID_TASKID);
			}
			task.setTaskID(taskID);
		} catch (NumberFormatException e) {
			throw new NumberFormatException(MESSAGE_INVALID_TASKID);
		}
		input = Utility.removeFirstWord(input);
				
		Pattern byKeywordPattern = Pattern.compile("(B|b)(Y|y)\\s+");
		Pattern fromKeywordPattern = Pattern.compile("(F|f)(R|r)(O|o)(M|m)\\s+");
		Matcher byKeywordMatcher = byKeywordPattern.matcher(input);
		Matcher fromKeywordMatcher = fromKeywordPattern.matcher(input);
		        
		if (byKeywordMatcher.find()){
		    // Remove 'by'
			input = Utility.removeFirstWord(input);
					
			task.setUpdateType(UPDATETYPE.DEADLINE);
			task.setEndTime(parseDate.parseInput(input));
			if (task.getEndTime().isEmpty()
					|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
				throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
			} 

		} else if (fromKeywordMatcher.find()){
		    splitOnToKeyword(task,input);
		    task.setUpdateType(UPDATETYPE.TIMEFRAME);
		} else {
		    if (input.isEmpty()){
		    	throw new IllegalArgumentException(MESSAGE_INVALID_DESCRIPTION);
		    } else {
		        task.setDescription(input);
		        task.setUpdateType(UPDATETYPE.DESCRIPTION);		    	
		    }

		}
	}
	
	/**
	 * For Update 
	 * Splits input based on keyword "to"
	 * @param taskDetails
	 * @return
	 */
	private void splitOnToKeyword(Task task,String taskDetails) {
		// Remove "from"
		taskDetails = Utility.removeFirstWord(taskDetails);
		String[] details = taskDetails.split("\\s+(T|t)(O|o)\\s+");
		parseDate.setParsingStartTime(true);
		task.setStartTime(parseDate.parseInput(details[0]));
		if (task.getStartTime().isEmpty()
				|| task.getStartTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_TIME);
		}
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.parseInput(details[1]));
		if (task.getEndTime().isEmpty()
				|| task.getEndTime().compareTo(parseDate.getCurrentTime()) < 0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		if (task.getStartTime().compareTo(task.getEndTime())>0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_END_TIME);
		}
	}
	
	

	
}



	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\UpdateExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\Utility.java
	 */

package whatsupnext.parser.extractor;


/**
 * This class contains repeatedly used functions in Extractors
 *
 */
public final class Utility {

	private Utility(){
		
	}

	/**
	 * Count the total number of words in a string
	 * @param userCommand
	*/
	public static int countWords (String input) {
		String trim = input.trim();
		if (trim.isEmpty()) {
			return 0;
		}
		// Separate string around 1 or more spaces
		return trim.split("\\s+").length;
	}
	
	/**
	 * Removes the first word of a string
	 * @param userCommand
	 * @return
	 */
	public static String removeFirstWord(String userCommand) {
		String commandString;
		try {
			commandString = userCommand.trim().split("\\s+", 2)[1];
		} catch (ArrayIndexOutOfBoundsException e) {
			commandString = "";
		}
		return commandString;
	}
	
	
	
	/**
	 * Returns the first word of an input string
	 * @param userCommand
	 * @return
	 */
    public static String getFirstWord(String userCommand) {
		String commandTypeString = userCommand.trim().split("\\s+")[0];
		return commandTypeString;
	}
    
    
	/**
	 * This method is to recover task description containing keyword
	 * @param details
	 * @return
	 */
	public static String recoverDetails(String keyword, String[] details) {
		// TODO Auto-generated method stub
		int detailsSize = details.length;
		String recoveredDetail = "";
		for (int i=0; i<detailsSize-1; i++) {
			recoveredDetail += " " + keyword + " " + details[i]; 
		}
		return removeFirstWord(recoveredDetail);	
	}
	
    
}


	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\Utility.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\ViewExtractor.java
	 */

package whatsupnext.parser.extractor;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import whatsupnext.structure.enums.Types.VIEWTYPE;
import whatsupnext.structure.util.Task;

public class ViewExtractor implements Extractor {
	
	private final String MESSAGE_INVALID_END_TIME = "'view' must have an valid end time";
	private final String MESSAGE_INVALID_START_TIME = "'view' must have an valid start time";
	private final String MESSAGE_INVALID_DATE = "'view' must have an valid date";
	private final String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
	
	private ParseDate parseDate;
	
	public ViewExtractor(){
		this.parseDate = new ParseDate();
	}
	
	public void extract(Task task, String input){
		int numOfWord = Utility.countWords(input);
		if ( numOfWord == 0){
			viewCaseUndone(task);
		} else if (numOfWord == 1) {
			if (input.equalsIgnoreCase("all")) {
				viewCaseAll(task);
			} else if (input.equalsIgnoreCase("next")) {
				viewCaseNext(task);
			} else if (input.equalsIgnoreCase("overdue")){
				viewCaseOverdue(task);
			} else {
				viewCaseDate(task,input);
			}
		} else {
	        Pattern fromKeywordPattern = Pattern.compile("(F|f)(R|r)(O|o)(M|m)\\s+");
	        Matcher fromKeywordMatcher = fromKeywordPattern.matcher(input);
	        if (fromKeywordMatcher.find()) {
	        	viewCaseTimeFrame(task,input);
	        } else {
	        	viewCaseDate(task,input);
	        }
		}
	}
	
	
	/**
	 *  View case for overdue tasks
	 * @param task
	 */
	private void viewCaseOverdue(Task task) {
		task.setViewType(VIEWTYPE.OVERDUE);
		task.setEndTime(parseDate.getCurrentTime());
	}

	/**
	 *  View case for only tasks not done 
	 * @param task
	 */
    private void viewCaseUndone(Task task) {
    	task.setViewType(VIEWTYPE.UNDONE);	
	}

	/**
     * View case for Time frame: start time and end time gven
     * @param task
     * @param viewDetail
     */
	private void viewCaseTimeFrame(Task task, String viewDetail) {
		task.setViewType(VIEWTYPE.TIMEFRAME);
		splitOnToKeyword(task,viewDetail);
	}

	/**
	 * View case: date
	 * @param task
	 * @param viewDetail
	 */
	private void viewCaseDate(Task task, String viewDetail) {
		task.setViewType(VIEWTYPE.DATE);
		task.setEndTime(parseDate.parseInput(viewDetail));
		if (task.getEndTime().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_DATE);
		} 
	}

	/**
	 * View case: next
	 * @param task
	 */
	private void viewCaseNext(Task task) {
		task.setViewType(VIEWTYPE.NEXT);
		task.setEndTime(parseDate.getCurrentTime());
	}

	/**
	 * View case: all
	 * @param task
	 */
	private void viewCaseAll(Task task) {
		task.setViewType(VIEWTYPE.ALL);
	}
	
	
	/**
	 * For Update 
	 * Splits input based on keyword "to"
	 * @param taskDetails
	 * @return
	 */
	private void splitOnToKeyword(Task task,String taskDetails) {
		// Remove "from"
		taskDetails = Utility.removeFirstWord(taskDetails);
		String[] details = taskDetails.split("\\s+(T|t)(O|o)\\s+");
		parseDate.setParsingStartTime(true);
		task.setStartTime(parseDate.parseInput(details[0]));
		if (task.getStartTime().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_START_TIME);
		}
		parseDate.setParsingStartTime(false);
		task.setEndTime(parseDate.parseInput(details[1]));
		if (task.getEndTime().isEmpty()){
			throw new IllegalArgumentException(MESSAGE_INVALID_END_TIME);
		}
		if (task.getStartTime().compareTo(task.getEndTime())>0) {
			throw new IllegalArgumentException(MESSAGE_INVALID_START_END_TIME);
		}
	}
	
		
	
}




	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\ViewExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\ui\widgets\FloatingTasksWidget.java
	 */

	/**
	 * This function displays feedback with customized coloring
	 * @param feedback
	 */
	private void appendToPane(String feedback) {
		textDisplayFloating.setText(feedback);
		int numOfNewline = countSubstring("\n", feedback);
		String[] subStrings = feedback.trim().split("\n");
		int currentStart = 0;
		int currentEnd = feedback.indexOf("\n",1);
		String subString;
		boolean newtask=true;
		Color lastColor = generateNewColor();
      			
	     for (int i = 0; i <= numOfNewline; i++) {
	    	 currentEnd = feedback.indexOf("\n",currentStart+1);
	    	 if (currentEnd<0) {
	    		 currentEnd=doc.getLength();
	    	 }
             SimpleAttributeSet set = new SimpleAttributeSet();
 
             subString = subStrings[i]; 
             // This line is a task title
             if (isnewTask(subString)){
            	 StyleConstants.setBold(set, true); 
            	 StyleConstants.setFontSize(set, 12);      
            	 StyleConstants.setBackground(set, titleBackground);
            	 StyleConstants.setForeground(set, titleForeground);
            	 newtask=true;
             } else {
            	 StyleConstants.setBold(set, false); 
            	 StyleConstants.setFontSize(set, 11);
            	 if (newtask){
                    lastColor = generateNewColor();
                    newtask = false;
            	 } 
            	 StyleConstants.setForeground(set, lastColor);
             }
             doc.setCharacterAttributes(currentStart, currentEnd-currentStart+1, set, true);
             currentStart = currentEnd + 1;
         }
	}
	
		
	/**
	 * This function generates a new font color without repeating last one
	 * @return
	 */
	private Color generateNewColor(){
		int newColorIndex = random.nextInt(colors.length-1);
		while (newColorIndex == currentColorIndex){
			newColorIndex = random.nextInt(colors.length-1);
		}
		currentColorIndex = newColorIndex;
		return colors[newColorIndex];
	}
	
	/**
	 * This function judges if a string is title of a task
	 * based on if it starts with "<taskID:>"
	 * @param subString
	 * @return
	 */
	private boolean isnewTask(String subString) {
		subString = subString.trim().split("\n")[0];
		String taskID = subString.trim().split(":")[0];
		try {
			Integer.parseInt(taskID); 
			return true;
		}  catch (NumberFormatException e) {
			return false;
		}	
	}

	/**
	 * This function counts the number of lines inside a string
	 * @param subStr
	 * @param str
	 * @return
	 */
	public static int countSubstring(String subStr, String str){
		return (str.length() - str.replace(subStr, "").length()) / subStr.length();
	}
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\ui\widgets\FloatingTasksWidget.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\ui\widgets\MainDisplayWidget.java
	 */

	/**
	 * This function displays feedback with customized coloring
	 * @param feedback
	 */
	private void appendToPane(String feedback) {
		textDisplayMain.setText("\n"+feedback+"\n");
		int numOfNewline = countSubstring("\n", feedback);
		String[] subStrings = feedback.trim().split("\n");
		int currentStart = 0;
		int currentEnd = feedback.indexOf("\n",1);
		String subString;
		boolean newtask=true;
		Color lastColor = generateNewColor();
      			
	     for (int i = 0; i <= numOfNewline; i++) {
	    	 currentEnd = feedback.indexOf("\n",currentStart+1);
	    	 if (currentEnd<0) {
	    		 currentEnd=doc.getLength();
	    	 }
             SimpleAttributeSet set = new SimpleAttributeSet();
 
             subString = subStrings[i]; 
             // This line is a task title
             if (isnewTask(subString)){
            	 StyleConstants.setBold(set, true); 
            	 StyleConstants.setFontSize(set, 13);      
            	 StyleConstants.setBackground(set, titleBackground);
            	 StyleConstants.setForeground(set, titleForeground);
            	 newtask=true;
             } else {
            	 StyleConstants.setBold(set, false); 
            	 StyleConstants.setFontSize(set, 11);
            	 if (newtask){
                    lastColor = generateNewColor();
                    newtask = false;
            	 } 
            	 StyleConstants.setForeground(set, lastColor);
             }
             doc.setCharacterAttributes(currentStart, currentEnd-currentStart+1, set, true);
             currentStart = currentEnd + 1;
         }
	}
	
		
	/**
	 * This function generates a new font color without repeating last one
	 * @return
	 */
	private Color generateNewColor(){
		int newColorIndex = random.nextInt(colors.length-1);
		while (newColorIndex == currentColorIndex){
			newColorIndex = random.nextInt(colors.length-1);
		}
		currentColorIndex = newColorIndex;
		return colors[newColorIndex];
	}
	
	/**
	 * This function judges if a string is title of a task
	 * based on if it starts with "<taskID:>"
	 * @param subString
	 * @return
	 */
	private boolean isnewTask(String subString) {
		subString = subString.trim().split("\n")[0];
		String taskID = subString.trim().split(":")[0];
		try {
			Integer.parseInt(taskID); 
			return true;
		}  catch (NumberFormatException e) {
			return false;
		}	
	}

	/**
	 * This function counts the number of lines inside a string
	 * @param subStr
	 * @param str
	 * @return
	 */
	public static int countSubstring(String subStr, String str){
		return (str.length() - str.replace(subStr, "").length()) / subStr.length();
	}
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\ui\widgets\MainDisplayWidget.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\ui\widgets\UpcomingTasksWidget.java
	 */

	/**
	 * This function displays feedback with customized coloring
	 * @param feedback
	 */
	private void appendToPane(String feedback) {
		textDisplayUpcoming.setText(feedback);
		int numOfNewline = countSubstring("\n", feedback);
		
		String[] subStrings = feedback.trim().split("\n");
		int currentStart = 0;
		int currentEnd = feedback.indexOf("\n",1);
		
		String subString;
		boolean newtask = true;
		Color lastColor = generateNewColor();
      			
	     for (int i = 0; i <= numOfNewline; i++) {
	    	 currentEnd = feedback.indexOf("\n",currentStart+1);
	    	 if (currentEnd < 0) {
	    		 currentEnd = doc.getLength();
	    	 }
             SimpleAttributeSet set = new SimpleAttributeSet();
 
             subString = subStrings[i]; 
             // This line is a task title
             if (isNewTask(subString)) {
            	 StyleConstants.setBold(set, true); 
            	 StyleConstants.setFontSize(set, 12);      
            	 StyleConstants.setBackground(set, titleBackground);
            	 StyleConstants.setForeground(set, titleForeground);
            	 newtask = true;
            	 
             } else {
            	 StyleConstants.setBold(set, false); 
            	 StyleConstants.setFontSize(set, 11);
            	 if (newtask) {
                    lastColor = generateNewColor();
                    newtask = false;
            	 } 
            	 StyleConstants.setForeground(set, lastColor);
             }
             doc.setCharacterAttributes(currentStart, currentEnd - currentStart + 1, set, true);
             currentStart = currentEnd + 1;
         }
	}
	
		
	/**
	 * This function generates a new font color without repeating last one
	 * @return
	 */
	private Color generateNewColor(){
		int newColorIndex = random.nextInt(colors.length-1);
		while (newColorIndex == currentColorIndex){
			newColorIndex = random.nextInt(colors.length-1);
		}
		currentColorIndex = newColorIndex;
		return colors[newColorIndex];
	}
	
	/**
	 * This function judges if a string is title of a task
	 * based on if it starts with "<taskID:>"
	 * @param subString
	 * @return
	 */
	private boolean isNewTask(String subString) {
		subString = subString.trim().split("\n")[0];
		String taskID = subString.trim().split(":")[0];
		try {
			Integer.parseInt(taskID); 
			return true;
		}  catch (NumberFormatException e) {
			return false;
		}	
	}

	/**
	 * This function counts the number of lines inside a string
	 * @param subStr
	 * @param str
	 * @return
	 */
	public static int countSubstring(String subStr, String str){
		return (str.length() - str.replace(subStr, "").length()) / subStr.length();
	}
	
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\ui\widgets\UpcomingTasksWidget.java





