//@author: a0111773l



	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\parser\ParseDateTest.java
	 */

package whatsupnext.junit.parser;

import static org.junit.Assert.*;

import java.util.Calendar;

import org.junit.Test;

import whatsupnext.parser.extractor.ParseDate;

public class ParseDateTest {

	private final int DAYS_IN_WEEK = 7;
	
	@Test
	/* This is a boundary case for the 'time date' partition */
	public void testParseTimeDate() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("2359 010414");
		assertEquals("HHmm ddMMyy", "201404012359", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 04012014");
		assertEquals("HHmm ddMMyyyy", "201401040102", formattedDate);
		
		formattedDate = parseDate.parseInput("1315 25/12/14");
		assertEquals("HHmm dd/MM/yy", "201412251315", formattedDate);
		
		formattedDate = parseDate.parseInput("1315 25/12/2014");
		assertEquals("HHmm dd/MM/yyyy", "201412251315", formattedDate);
	
		formattedDate = parseDate.parseInput("0909 03-04-14");
		assertEquals("HHmm dd-MM-yy", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("0909 03-04-2014");
		assertEquals("HHmm dd-MM-yyyy", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("23:59 010414");
		assertEquals("HH:mm ddMMyy", "201404012359", formattedDate);
		
		formattedDate = parseDate.parseInput("01:02 04012014");
		assertEquals("HH:mm ddMMyyyy", "201401040102", formattedDate);
		
		formattedDate = parseDate.parseInput("13:15 25/12/14");
		assertEquals("HH:mm dd/MM/yy", "201412251315", formattedDate);
		
		formattedDate = parseDate.parseInput("13:15 25/12/2014");
		assertEquals("HH:mm dd/MM/yyyy", "201412251315", formattedDate);
	
		formattedDate = parseDate.parseInput("09:09 03-04-14");
		assertEquals("HH:mm dd-MM-yy", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("09:09 03-04-2014");
		assertEquals("HH:mm dd-MM-yyyy", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("11:59 PM 010414");
		assertEquals("h:mm a ddMMyy", "201404012359", formattedDate);
		
		formattedDate = parseDate.parseInput("9:09 am 03-04-2014");
		assertEquals("h:mm a dd-MM-yyyy", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("1 am 04012014");
		assertEquals("h a ddMMyyyy", "201401040100", formattedDate);
		
		formattedDate = parseDate.parseInput("1 pm 25/12/14");
		assertEquals("h a dd/MM/yy", "201412251300", formattedDate);
		
		formattedDate = parseDate.parseInput("1 pm 25 dec 14");
		assertEquals("h a dd MMM yy", "201412251300", formattedDate);
		
		formattedDate = parseDate.parseInput("1 pm 25 december 2014");
		assertEquals("h a dd MMMM yyyy", "201412251300", formattedDate);
		
	}
	
	@Test
	/* This is a boundary case for the 'date time' partition */
	public void testParseDateTime() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("010414 2359");
		assertEquals("ddMMyy HHmm", "201404012359", formattedDate);
		
		formattedDate = parseDate.parseInput("04012014 0102");
		assertEquals("ddMMyyyy HHmm", "201401040102", formattedDate);
		
		formattedDate = parseDate.parseInput("25/12/14 1315");
		assertEquals("dd/MM/yy HHmm", "201412251315", formattedDate);
		
		formattedDate = parseDate.parseInput("25/12/2014 1315");
		assertEquals("dd/MM/yyyy HHmm", "201412251315", formattedDate);
		
		formattedDate = parseDate.parseInput("03-04-14 0909");
		assertEquals("dd-MM-yy HHmm", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("03-04-2014 0909");
		assertEquals("dd-MM-yyyy HHmm", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("010414 23:59");
		assertEquals("ddMMyy HH:mm", "201404012359", formattedDate);
		
		formattedDate = parseDate.parseInput("04012014 01:02");
		assertEquals("ddMMyyyy HH:mm", "201401040102", formattedDate);
		
		formattedDate = parseDate.parseInput("25/12/14 13:15");
		assertEquals("dd/MM/yy HH:mm", "201412251315", formattedDate);
		
		formattedDate = parseDate.parseInput("25/12/2014 13:15");
		assertEquals("dd/MM/yyyy HH:mm", "201412251315", formattedDate);
		
		formattedDate = parseDate.parseInput("03-04-14 09:09");
		assertEquals("dd-MM-yy HH:mm", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("03-04-2014 09:09");
		assertEquals("dd-MM-yyyy HH:mm", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("010414 23:59 pm");
		assertEquals("ddMMyy h:mm a", "201404012359", formattedDate);
		
		formattedDate = parseDate.parseInput("03-04-2014 09:09 AM");
		assertEquals("dd-MM-yyyy h:mm a", "201404030909", formattedDate);
		
		formattedDate = parseDate.parseInput("04012014 1 AM");
		assertEquals("ddMMyyyy h a", "201401040100", formattedDate);
		
		formattedDate = parseDate.parseInput("25/12/14 1 PM");
		assertEquals("dd/MM/yy h a", "201412251300", formattedDate);
		
		formattedDate = parseDate.parseInput("04 jan 14 1 AM");
		assertEquals("dd MMM yy h a", "201401040100", formattedDate);
		
		formattedDate = parseDate.parseInput("25 december 2014 1 PM");
		assertEquals("dd MMMM yy h a", "201412251300", formattedDate);
		
	}
	
	@Test
	/* This is a boundary case for the 'time' partition */
	public void testParseStandaloneTime() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("1234");
		assertEquals("HHmm", getTodayDate()+"1234", formattedDate);
		
		formattedDate = parseDate.parseInput("12:34");
		assertEquals("HH:mm", getTodayDate()+"1234", formattedDate);
		
		formattedDate = parseDate.parseInput("12:34 pm");
		assertEquals("h:mm a", getTodayDate()+"1234", formattedDate);
		
		formattedDate = parseDate.parseInput("12:43 am");
		assertEquals("h:mm a", getTodayDate()+"0043", formattedDate);
		
		formattedDate = parseDate.parseInput("1:59 PM");
		assertEquals("h:mm a", getTodayDate()+"1359", formattedDate);
		
		formattedDate = parseDate.parseInput("11 PM");
		assertEquals("h a", getTodayDate()+"2300", formattedDate);
		
		formattedDate = parseDate.parseInput("5 AM");
		assertEquals("h a", getTodayDate()+"0500", formattedDate);
	}
	
	@Test
	/* This is a boundary case for the 'date' partition */
	public void testParseStandaloneDate() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("290914");
		assertEquals("Test ddMMyy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29092014");
		assertEquals("Test ddMMyyyy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29/09/14");
		assertEquals("Test dd/MM/yy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29/09/2014");
		assertEquals("Test dd/MM/yyyy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29-09-14");
		assertEquals("Test dd-MM-yy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29-09-2014");
		assertEquals("Test dd-MM-yyyy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29 sep 14");
		assertEquals("dd MMM yy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29 sep 2014");
		assertEquals("dd MMM yyyy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29 september 14");
		assertEquals("dd MMMM yy", "201409292359", formattedDate);
		
		formattedDate = parseDate.parseInput("29 september 2014");
		assertEquals("dd MMMM yyyy", "201409292359", formattedDate);
		
		parseDate.setParsingStartTime(true);
		formattedDate = parseDate.parseInput("29-09-2014");
		assertEquals("dd-MM-yyyy 0000", "201409290000", formattedDate);
		
		parseDate.setParsingStartTime(false);
		formattedDate = parseDate.parseInput("29-09-2014");
		assertEquals("dd-MM-yyyy 2359", "201409292359", formattedDate);
	}
	
	@Test
	/* This is a boundary case for the 'time day' partition */
	public void testParseTimeDay() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("0102 today");
		assertEquals("HHmm today", getTodayDate()+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 tomorrow");
		assertEquals("HHmm tomorrow", getTomorrowDate()+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 sunday");
		assertEquals("HHmm sunday", getNextDayOfWeekDate(Calendar.SUNDAY)+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 monday");
		assertEquals("HHmm monday", getNextDayOfWeekDate(Calendar.MONDAY)+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 tuesday");
		assertEquals("HHmm tuesday", getNextDayOfWeekDate(Calendar.TUESDAY)+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 wednesday");
		assertEquals("HHmm wednesday", getNextDayOfWeekDate(Calendar.WEDNESDAY)+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 thursday");
		assertEquals("HHmm thursday", getNextDayOfWeekDate(Calendar.THURSDAY)+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 friday");
		assertEquals("HHMm friday", getNextDayOfWeekDate(Calendar.FRIDAY)+"0102", formattedDate);
		
		formattedDate = parseDate.parseInput("0102 saturday");
		assertEquals("HHMm saturday", getNextDayOfWeekDate(Calendar.SATURDAY)+"0102", formattedDate);
		
		
	}
	
	@Test
	/* This is a boundary case for the 'day time' partition */
	public void testParseDayTime() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("Today 2222");
		assertEquals("Today HHmm", getTodayDate()+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Tml 2222");
		assertEquals("Tml HHmm", getTomorrowDate()+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Sun 2222");
		assertEquals("Sun HHmm ", getNextDayOfWeekDate(Calendar.SUNDAY)+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Mon 2222");
		assertEquals("Mon HHmm", getNextDayOfWeekDate(Calendar.MONDAY)+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Tue 2222");
		assertEquals("Tue HHmm", getNextDayOfWeekDate(Calendar.TUESDAY)+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Wed 2222");
		assertEquals("Wed HHmm", getNextDayOfWeekDate(Calendar.WEDNESDAY)+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Thu 2222");
		assertEquals("Thu HHmm", getNextDayOfWeekDate(Calendar.THURSDAY)+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Fri 2222");
		assertEquals("Fri HHmm", getNextDayOfWeekDate(Calendar.FRIDAY)+"2222", formattedDate);
		
		formattedDate = parseDate.parseInput("Sat 2222");
		assertEquals("Sat HHmm", getNextDayOfWeekDate(Calendar.SATURDAY)+"2222", formattedDate);
		
	}
	
	@Test
	/* This is a boundary case for the 'day' partition */
	public void testParseStandaloneDay() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("today");
		assertEquals("today", getTodayDate()+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Tomorrow");
		assertEquals("Tomorrow", getTomorrowDate()+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("tml");
		assertEquals("tml", getTomorrowDate()+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Sunday");
		assertEquals("Sunday", getNextDayOfWeekDate(Calendar.SUNDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("sun");
		assertEquals("sun", getNextDayOfWeekDate(Calendar.SUNDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Monday");
		assertEquals("Monday", getNextDayOfWeekDate(Calendar.MONDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("mon");
		assertEquals("mon", getNextDayOfWeekDate(Calendar.MONDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Tuesday");
		assertEquals("Tuesday", getNextDayOfWeekDate(Calendar.TUESDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("tue");
		assertEquals("tue", getNextDayOfWeekDate(Calendar.TUESDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Wednesday");
		assertEquals("Wednesday", getNextDayOfWeekDate(Calendar.WEDNESDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("wed");
		assertEquals("wed", getNextDayOfWeekDate(Calendar.WEDNESDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Thursday");
		assertEquals("Thursday", getNextDayOfWeekDate(Calendar.THURSDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("thu");
		assertEquals("thu", getNextDayOfWeekDate(Calendar.THURSDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Friday");
		assertEquals("Friday", getNextDayOfWeekDate(Calendar.FRIDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("fri");
		assertEquals("fri", getNextDayOfWeekDate(Calendar.FRIDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("Saturday");
		assertEquals("Saturday", getNextDayOfWeekDate(Calendar.SATURDAY)+"2359", formattedDate);
		
		formattedDate = parseDate.parseInput("sat");
		assertEquals("sat", getNextDayOfWeekDate(Calendar.SATURDAY)+"2359", formattedDate);
		
		parseDate.setParsingStartTime(true);
		formattedDate = parseDate.parseInput("today");
		assertEquals("Today 0000", getTodayDate()+"0000", formattedDate);
		
		parseDate.setParsingStartTime(false);
		formattedDate = parseDate.parseInput("today");
		assertEquals("Today 2359", getTodayDate()+"2359", formattedDate);
	}
	
	@Test
	/* This is a test case for the 'now' partition */
	public void testParseCurrentTime() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		formattedDate = parseDate.parseInput("now");
		assertEquals("Today", getCurrentTime(), formattedDate);
		
		formattedDate = parseDate.parseInput("Now");
		assertEquals("Today", getCurrentTime(), formattedDate);
		
	}
	
	@Test
	public void testParseInvalid() {
		ParseDate parseDate = new ParseDate();
		String formattedDate = "";
		
		/* This is a boundary case for the 'any other days' partition */
		formattedDate = parseDate.parseInput("rubbish");
		assertEquals("Invalid day", "", formattedDate);
		
		/* This is a boundary case for the 'any other years' partition */
		formattedDate = parseDate.parseInput("03/03/20154");
		assertEquals("Invalid year", "", formattedDate);
		
		/* This is a boundary case for the 'any other time format' partition */
		formattedDate = parseDate.parseInput("1144 PM");
		assertEquals("Invalid time format", "", formattedDate);
		
		/* This is a boundary case for the 'any other date format' partition */
		formattedDate = parseDate.parseInput("04:04:14");
		assertEquals("Invalid date format", "", formattedDate);
		
		/* This is a boundary case for the 'MAX_24_HOUR+1' partition */
		formattedDate = parseDate.parseInput("2459 040114");
		assertEquals("Invalid HH", "", formattedDate);
		
		/* This is a boundary case for the 'MAX_MINUTE+1' partition */
		formattedDate = parseDate.parseInput("2360 040114");
		assertEquals("Invalid mm", "", formattedDate);
		
		/* This is a boundary case for the 'MAX_12_HOUR+1' partition */
		formattedDate = parseDate.parseInput("13 AM 040114");
		assertEquals("Invalid h", "", formattedDate);
		
		/* This is a boundary case for the 'MAX_MONTH+1' partition */
		formattedDate = parseDate.parseInput("2359 041314");
		assertEquals("Invalid MM", "", formattedDate);
		
		/* This is a boundary case for the 'MAX_DAYOFMONTH+1' partition */
		formattedDate = parseDate.parseInput("320314");
		assertEquals("Invalid dd", "", formattedDate);
	
	}
	
	private String getCurrentTime() {
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH)+1;
		int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
		int hour = cal.get(Calendar.HOUR_OF_DAY);
		int minute = cal.get(Calendar.MINUTE);
		String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth);
		String twoDigitHour = convertToTwoDigits(hour);
		String twoDigitMinute = convertToTwoDigits(minute);

		return year + twoDigitMonth + twoDigitDayOfMonth + twoDigitHour + twoDigitMinute; 
	}
	
	private String getTodayDate() {
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth); 
          
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	private String getTomorrowDate() {
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DAY_OF_YEAR, 1);
		int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth); 
          
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	/**
	 * Get the expected day of week date based on today
	 */
	private String getNextDayOfWeekDate(int expectedDayOfWeek) {
		Calendar cal = Calendar.getInstance();
		int numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), expectedDayOfWeek);
		cal.add(Calendar.DAY_OF_YEAR, numOfDay);
		
		int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth); 
          
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	private int getNumOfDay(int currentDayOfWeek, int expectedDayOfWeek) {
		int numOfDay = 0;
		int newDay = 0;
		for(int i = 1; i <= DAYS_IN_WEEK; i++) {
			newDay = currentDayOfWeek + i; 
			if(newDay > DAYS_IN_WEEK) {
				newDay = (currentDayOfWeek + i) % DAYS_IN_WEEK;
			}
			if (newDay == expectedDayOfWeek) {
				numOfDay = i;
				break;
			}
		}
		
		return numOfDay;
	}
	
	private String convertToTwoDigits(int value){
		if(value < 10) {
			return "0" + value;
		} else {
			return "" + value;
		}
	}
	
	
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\parser\ParseDateTest.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\parser\ParserTest.java
	 */

package whatsupnext.junit.parser;
import static org.junit.Assert.*;

import java.util.Calendar;

import org.junit.Test;

import whatsupnext.parser.api.Parser;
import whatsupnext.parser.extractor.ParseDate;
import whatsupnext.structure.enums.OPCODE;
import whatsupnext.structure.enums.Types.ADDTYPE;
import whatsupnext.structure.enums.Types.DELETETYPE;
import whatsupnext.structure.enums.Types.UPDATETYPE;
import whatsupnext.structure.enums.Types.VIEWTYPE;
import whatsupnext.structure.util.Task;

public class ParserTest {
	
	@Test
	/* This is a test case for the 'add timeframe' partition */
	public void testParserAddTimeframe() {
		String input = "add dine with Amy from 7 am tml to 9 AM tomorrow";	
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE",OPCODE.ADD,task.getOpCode());
        assertEquals("addType",ADDTYPE.TIMEFRAME,task.getAddType());
		assertEquals("description", "dine with Amy", task.getDescription());
		assertEquals("startTime", getTomorrowDate()+"0700", task.getStartTime());
		assertEquals("endTime", getTomorrowDate()+"0900", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'add deadline' partition */
	public void testParserAddDeadline() {
		String input = "add submit report by 10 PM tml";	
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.ADD, task.getOpCode());
        assertEquals("addType",ADDTYPE.DEADLINE,task.getAddType());
		assertEquals("description", "submit report", task.getDescription());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", getTomorrowDate()+"2200", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'add floating' partition */
	public void testParserAddFloating() {
		String input = "add submit report";	
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.ADD, task.getOpCode());
        assertEquals("addType",ADDTYPE.FLOATING,task.getAddType());
		assertEquals("description", "submit report", task.getDescription());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", "", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'add empty' partition */
	public void testParserAddInvalidDesc() {
		String MESSAGE_INVALID_DESCRIPTION = "'add' must have a valid description";
		String input = "add";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'add invalid start_time' partition */
	public void testParserAddInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'add' must have a valid start time";
		String input = "add invalid from 23/09/14 to tml";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'add invalid end_time' partition */
	public void testParserAddInvalidEndtime() {
		String MESSAGE_INVALID_END_TIME = "'add' must have a valid end time";
		String input = "add invalid from tml to 23/09/14";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'add invalid start_end_time' partition */
	public void testParserAddInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		String input = "add invalid from tml to today";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'update timeframe' partition */
	public void testParserUpdateTimeframe() {
		String input = "update 19 from tml 9 am to tml 12 pm";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.UPDATE, task.getOpCode());
		assertEquals("updateType", UPDATETYPE.TIMEFRAME, task.getUpdateType());
        assertEquals("taskID", "19", task.getTaskID());
		assertEquals("description", "", task.getDescription());
		assertEquals("startTime", getTomorrowDate()+"0900", task.getStartTime());
		assertEquals("endTime", getTomorrowDate()+"1200", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'update deadline' partition */
	public void testParserUpdateDeadline() {
		String input = "update 19 by 18:00 tml";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.UPDATE, task.getOpCode());
        assertEquals("updateType", UPDATETYPE.DEADLINE, task.getUpdateType());
        assertEquals("taskID", "19", task.getTaskID());
		assertEquals("description", "", task.getDescription());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", getTomorrowDate()+"1800", task.getEndTime());	
	}
	
	@Test
	/* This is a test case for the 'update floating' partition */
	public void testParserUpdateDescription() {
		String input = "update 19 new descripitions1234";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.UPDATE, task.getOpCode());
        assertEquals("updateType", UPDATETYPE.DESCRIPTION, task.getUpdateType());
        assertEquals("taskID", "19", task.getTaskID());
		assertEquals("description", "new descripitions1234", task.getDescription());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", "", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'update invalid ID' partition */
	public void testParserUpdateInvalidID() {
		String MESSAGE_INVALID_TASKID = "'update' must have a valid Task ID";
		String input = "update -1";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_TASKID, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'update empty' partition */
	public void testParserUpdateInvalidDesc() {
		String MESSAGE_INVALID_DESCRIPTION = "'update' must have a valid description";
		String input = "update 19";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'update invalid start_time' partition */
	public void testParserUpdateInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'update' must have a valid start time";
		String input = "update 19 d from 23/09/14 to tml";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'update invalid end_time' partition */
	public void testParserUpdateInvalidEndtime() {
		String MESSAGE_INVALID_END_TIME = "'update' must have a valid end time";
		String input = "update 19 by 23/09/14";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'update invalid start_end_time' partition */
	public void testParserUpdateInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		String input = "update 19 from tml to today";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'view undone' partition */
	public void testParserViewUndone() {
		String input = "view";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.VIEW, task.getOpCode());
		assertEquals("viewType", VIEWTYPE.UNDONE, task.getViewType());
	}
	
	@Test
	/* This is a test case for the 'view all' partition */
	public void testParserViewAll() {
		String input = "view all";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.VIEW, task.getOpCode());
		assertEquals("viewType", VIEWTYPE.ALL, task.getViewType());
	}
	
	@Test
	/* This is a test case for the 'view next' partition */
	public void testParserViewNext() {
		String input = "view next";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.VIEW, task.getOpCode());
		assertEquals("viewType", VIEWTYPE.NEXT, task.getViewType());
	}
	
	@Test
	/* This is a test case for the 'view timeframe' partition */
	public void testParserViewTimeframe() {
		String input = "v from 1900 29092014 to 2030 29092014";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.VIEW, task.getOpCode());
        assertEquals("viewType", VIEWTYPE.TIMEFRAME, task.getViewType());
		assertEquals("description", "", task.getDescription());
		assertEquals("startTime", "201409291900", task.getStartTime());
		assertEquals("endTime", "201409292030", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'view date' partition */
	public void testParserViewDate() {
		String input = "view 1900 29092014";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.VIEW, task.getOpCode());
        assertEquals("viewType", VIEWTYPE.DATE, task.getViewType());
        assertEquals("description", "", task.getDescription());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", "201409291900", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'view invalid start_time' partition */
	public void testParserViewInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'view' must have an valid start time";
		String input = "view from 32/09/14 to tml";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'view invalid end_time' partition */
	public void testParserViewInvalidEndtime() {
		String MESSAGE_INVALID_END_TIME = "'view' must have an valid end time";
		String input = "view from today to 32/09/14";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'view invalid start_end_time' partition */
	public void testParserViewInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		String input = "view from tml to today";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'view invalid date' partition */
	public void testParserViewInvalidDate() {
		String MESSAGE_INVALID_DATE = "'view' must have an valid date";
		String input = "view 32/09/14";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_DATE, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'delete id' partition */
	public void testParserDeleteID() {
		String input = "delete 19";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.DELETE, task.getOpCode());
        assertEquals("deleteType", DELETETYPE.ID, task.getDeleteType());
        assertEquals("taskID", "19", task.getTaskID());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", "", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'delete deadline' partition */
	public void testParserDeleteTimeDeadline() {
		String input = "delete deadline";
		Parser parser = new Parser(input);
		ParseDate parseDate = new ParseDate();
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.DELETE, task.getOpCode());
        assertEquals("deleteType", DELETETYPE.DEADLINE, task.getDeleteType());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", parseDate.getCurrentTime(), task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'delete date' partition */
	public void testParserDeleteDate() {
		String input = "d 2030 29092014";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.DELETE, task.getOpCode());
        assertEquals("deleteType", DELETETYPE.DATE, task.getDeleteType());
		assertEquals("startTime", "", task.getStartTime());
		assertEquals("endTime", "201409292030", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'delete timeframe' partition */
	public void testParserDeleteTimeframe() {
		String input = "d from 1900 29092014 To 2030 29092014";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.DELETE, task.getOpCode());
        assertEquals("deleteType", DELETETYPE.TIMEFRAME, task.getDeleteType());
		assertEquals("startTime", "201409291900", task.getStartTime());
		assertEquals("endTime", "201409292030", task.getEndTime());
	}
	
	@Test
	/* This is a test case for the 'delete empty' partition */
	public void testParserDeleteInvalid() {
		String MESSAGE_INVALID_ARGUMENT = "'delete' must have an argument";
		String input = "delete";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_ARGUMENT, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'delete invalid start_time' partition */
	public void testParserDeleteInvalidStartTime() {
		String MESSAGE_INVALID_START_TIME = "'delete' must have an valid start time";
		String input = "delete from 32/09/14 to tml";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'delete invalid end_time' partition */
	public void testParserDeleteInvalidEndtime() {
		String MESSAGE_INVALID_END_TIME = "'delete' must have an valid end time";
		String input = "delete from today to 32/09/14";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'delete invalid start_end_time' partition */
	public void testParserDeleteInvalidStartEndTime() {
		String MESSAGE_INVALID_START_END_TIME = "Start time must be before end time"; 
		String input = "delete from tml to today";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_START_END_TIME, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'delete invalid date' partition */
	public void testParserdeleteInvalidDate() {
		String MESSAGE_INVALID_TASKID_OR_DATE = "'delete' must have a valid Task ID or Date";
		String input = "delete 32/09/14";	
		Parser parser = new Parser(input);
		try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
			assertEquals(MESSAGE_INVALID_TASKID_OR_DATE, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'search keyword' partition */
	public void testParserSearch() {
		String input = "search for this keyword";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.SEARCH, task.getOpCode());
        assertEquals("OPCODE", "for this keyword", task.getSearchKeyword());
	}
	
	@Test
	/* This is a test case for the 'search empty' partition */
	public void testParserSearchEmpty() {
		String MESSAGE_INVALID_DESCRIPTION = "'Search' must have valid keywords";
		String input = "search";
		Parser parser = new Parser(input);      
        try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
	        assertEquals("OPCODE", MESSAGE_INVALID_DESCRIPTION, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'done ID' partition */
	public void testParserDone() {
		String input = "done 13";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.DONE, task.getOpCode());
        assertEquals("ID", "13", task.getTaskID());
	}
	
	@Test
	/* This is a test case for the 'done empty' partition */
	public void testParserDoneEmpty() {
		String MESSAGE_INVALID_TASKID = "'Done' must have a valid ID";
		String input = "done";
		Parser parser = new Parser(input);      
        try {
			parser.parseInput();
		} catch (IllegalArgumentException e) {
	        assertEquals("OPCODE", MESSAGE_INVALID_TASKID, e.getMessage());
		}
	}
	
	@Test
	/* This is a test case for the 'undo' partition */
	public void testParserUndo() {
		String input = "undo";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.UNDO, task.getOpCode());
	}
	
	@Test
	/* This is a test case for the 'redo' partition */
	public void testParserRedo() {
		String input = "redo";
		Parser parser = new Parser(input);
		Task task = parser.parseInput();
        assertEquals("OPCODE", OPCODE.REDO, task.getOpCode());
	}
	
	private String getTomorrowDate() {
		Calendar cal = Calendar.getInstance();
		cal.add(Calendar.DAY_OF_YEAR, 1);
		int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH)+1;
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        String twoDigitMonth = "";
		String twoDigitDayOfMonth = ""; 
        if (month < 10) {
        	twoDigitMonth = "0" + month;
 		} else {
 			twoDigitMonth = "" + month;
 		}
 		if (dayOfMonth < 10) {
 			twoDigitDayOfMonth = "0" + dayOfMonth;
 		} else {
 			twoDigitDayOfMonth = "" + dayOfMonth;
 		}
         
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	
}
	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\parser\ParserTest.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\ui\GUIBehaviorTest.java
	 */

	@Test
	public void FreeTest() {
		String formattedUpcomingTime1 = LogicUtilities.getFormattedTime(getTodayDateForFormat("0600")).replaceAll(currentYear, "");
		String formattedUpcomingTime2 = LogicUtilities.getFormattedTime(getTodayDateForFormat("1500")).replaceAll(currentYear, "");
		String formattedUpcomingTime3 = LogicUtilities.getFormattedTime(getTodayDateForFormat("1700")).replaceAll(currentYear, "");
		String formattedUpcomingTime4 = LogicUtilities.getFormattedTime(getTodayDateForFormat("2200")).replaceAll(currentYear, "");
		
		Logic logic = new Logic("guiTest");
		Task task = new Task();
		task.setOpcode(OPCODE.ADD);
		task.setAddType(Types.ADDTYPE.TIMEFRAME);
		task.setDescription("todayTask");
		task.setStartTime(getTodayDateForFormat("1500"));
		task.setEndTime(getTodayDateForFormat("1700"));
		logic.executeTask(task);
		
		textInput.setText("free 2");
		buttonEnter.doClick();
		
		assertEquals(
				"\nAvailable time slots:" +
						"\n" + formattedUpcomingTime1.trim() + " -" + formattedUpcomingTime2 +
						"\n" + formattedUpcomingTime3.trim() + " -" + formattedUpcomingTime4 + "\n", 
						textDisplayMain.getText());
		assertEquals("1: todayTask" +
				"\n\tStart Time:" + formattedUpcomingTime2 +
					"\n\tEnd Time:" + formattedUpcomingTime3 + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void FreeByTest() {
		String formattedTodayTime1 = LogicUtilities.getFormattedTime(getTodayDateForFormat("0600")).replaceAll(currentYear, "");
		String formattedTodayTime2 = LogicUtilities.getFormattedTime(getTodayDateForFormat("2200")).replaceAll(currentYear, "");
		String formattedTmlTime1 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("0600")).replaceAll(currentYear, "");
		String formattedTmlTime2 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1500")).replaceAll(currentYear, "");
		String formattedTmlTime3 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1700")).replaceAll(currentYear, "");
		String formattedTmlTime4 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2200")).replaceAll(currentYear, "");
		
		textInput.setText("add tmlTask from 1500 tml to 1700 tml");
		buttonEnter.doClick();

		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedTmlTime3 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("free 2 by tml");
		buttonEnter.doClick();

		assertEquals(
				"\nAvailable time slots:" +
						"\n" + formattedTodayTime1.trim() + " -" + formattedTodayTime2 +
						"\n" + formattedTmlTime1.trim() + " -" + formattedTmlTime2 +
						"\n" + formattedTmlTime3.trim() + " -" + formattedTmlTime4 + "\n", 
						textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void FreeOnTest() {
		String formattedUpcomingTime1 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("0600")).replaceAll(currentYear, "");
		String formattedUpcomingTime2 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1500")).replaceAll(currentYear, "");
		String formattedUpcomingTime3 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1700")).replaceAll(currentYear, "");
		String formattedUpcomingTime4 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2200")).replaceAll(currentYear, "");
		
		textInput.setText("add tmlTask from 1500 tomorrow to 1700 tomorrow");
		buttonEnter.doClick();

		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedUpcomingTime3 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("free 2 on " + getTomorrowDate());
		buttonEnter.doClick();
		
		assertEquals(
				"\nAvailable time slots:" +
						"\n" + formattedUpcomingTime1.trim() + " -" + formattedUpcomingTime2 +
						"\n" + formattedUpcomingTime3.trim() + " -" + formattedUpcomingTime4 + "\n", 
						textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void FreeFromToTest() {
		String formattedTodayTime1 = LogicUtilities.getFormattedTime(getTodayDateForFormat("0600")).replaceAll(currentYear, "");
		String formattedTodayTime2 = LogicUtilities.getFormattedTime(getTodayDateForFormat("2200")).replaceAll(currentYear, "");
		String formattedTmlTime1 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("0600")).replaceAll(currentYear, "");
		String formattedTmlTime2 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1500")).replaceAll(currentYear, "");
		String formattedTmlTime3 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1700")).replaceAll(currentYear, "");
		String formattedTmlTime4 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2200")).replaceAll(currentYear, "");
		
		textInput.setText("add tmlTask from 1500 tml to 1700 tml");
		buttonEnter.doClick();

		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedTmlTime3 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("free 2 from now to " + getTomorrowDate());
		buttonEnter.doClick();

		assertEquals(
				"\nAvailable time slots:" +
						"\n" + formattedTodayTime1.trim() + " -" + formattedTodayTime2 +
						"\n" + formattedTmlTime1.trim() + " -" + formattedTmlTime2 +
						"\n" + formattedTmlTime3.trim() + " -" + formattedTmlTime4 + "\n", 
						textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}
	
	@Test
	public void UpdateByDeadlineDateTest() {
		textInput.setText("add update deadline test");
		buttonEnter.doClick();

		assertEquals("\nSuccessfully added to task 1.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("1: update deadline test\n\tNot done.", textDisplayFloating.getText());
		
		textInput.setText("update 1 by today");
		buttonEnter.doClick();
		
		String formattedUpcomingTime = LogicUtilities.getFormattedTime(getTodayDateForFormat("2359")).replaceAll(currentYear, "");
		
		assertEquals("\nSuccessfully updated the deadline of task 1.\n", textDisplayMain.getText());
		assertEquals("1: update deadline test" +
				"\n\tEnd Time:" + formattedUpcomingTime + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void UpdateFromToDateTest() {
		textInput.setText("add update timeframe test");
		buttonEnter.doClick();

		assertEquals("\nSuccessfully added to task 1.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("1: update timeframe test\n\tNot done.", textDisplayFloating.getText());
		
		textInput.setText("update 1 from 2359 today to 2359 today");
		buttonEnter.doClick();
		
		String formattedUpcomingTime = LogicUtilities.getFormattedTime(getTodayDateForFormat("2359")).replaceAll(currentYear, "");
		
		assertEquals("\nSuccessfully updated the time frame of task 1.\n", textDisplayMain.getText());
		assertEquals("1: update timeframe test" +
				"\n\tStart Time:" + formattedUpcomingTime
 				+"\n\tEnd Time:" + formattedUpcomingTime + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void DeleteTaskIdTest() {
		textInput.setText("add floating task test");
		buttonEnter.doClick();

		assertEquals("\nSuccessfully added to task 1.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("1: floating task test\n\tNot done.", textDisplayFloating.getText());
		
		textInput.setText("delete 1");
		buttonEnter.doClick();
		
		assertEquals("\nTask 1 is deleted.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}
	
	@Test
	public void DeleteDoneTest() {
		textInput.setText("add floating task test");
		buttonEnter.doClick();

		assertEquals("\nSuccessfully added to task 1.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("1: floating task test\n\tNot done.", textDisplayFloating.getText());
		
		textInput.setText("done 1");
		buttonEnter.doClick();
		
		assertEquals("\nTask 1 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("delete done");
		buttonEnter.doClick();
		
		assertEquals("\n1 tasks are deleted.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}
	
	@Test
	public void DeleteDeadlineTest() {
		Logic logic = new Logic("guiTest");
		Task task = new Task();
		task.setOpcode(OPCODE.ADD);
		task.setAddType(Types.ADDTYPE.DEADLINE);
		task.setDescription("overdue");
		task.setEndTime("201301012359");
		logic.executeTask(task);
		
		textInput.setText("done 1");
		buttonEnter.doClick();
		
		assertEquals("\nTask 1 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("delete deadline");
		buttonEnter.doClick();
		
		assertEquals("\n1 tasks are deleted.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
	}

	@Test
	public void DeleteDateTest() {
		textInput.setText("add tmlTask1 by 1800 tml");
		buttonEnter.doClick();
		String formattedUpcomingTime1 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1800")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedUpcomingTime1 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("add tmlTask2 by 2000 tml");
		buttonEnter.doClick();
		String formattedUpcomingTime2 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2000")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 2.\n\tDeadline:" + formattedUpcomingTime2 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("done 1");
		buttonEnter.doClick();
		
		assertEquals("\nTask 1 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("done 2");
		buttonEnter.doClick();
		
		assertEquals("\nTask 2 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("delete " + getTomorrowDate());
		buttonEnter.doClick();
		
		assertEquals("\n2 tasks are deleted.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void DeleteFromToDateTest() {
		textInput.setText("add tmlTask by 2000 tml");
		buttonEnter.doClick();
		String formattedUpcomingTime1 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2000")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedUpcomingTime1 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("add todayTask by 1800 today");
		buttonEnter.doClick();
		String formattedUpcomingTime2 = LogicUtilities.getFormattedTime(getTodayDateForFormat("1800")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 2.\n\tDeadline:" + formattedUpcomingTime2 + "\n",
				textDisplayMain.getText());
		assertEquals("2: todayTask" +
 				"\n\tEnd Time:" + formattedUpcomingTime2 + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("done 1");
		buttonEnter.doClick();
		
		assertEquals("\nTask 1 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("2: todayTask" +
 				"\n\tEnd Time:" + formattedUpcomingTime2 + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("done 2");
		buttonEnter.doClick();
		
		assertEquals("\nTask 2 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
				
		textInput.setText("delete from " + getTodayDate() + " to " + getTomorrowDate());
		buttonEnter.doClick();
		
		assertEquals("\n2 tasks are deleted.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}
	
	@Test
	public void ViewTest() {
		textInput.setText("add floating task test");
		buttonEnter.doClick();

		assertEquals("\nSuccessfully added to task 1.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("1: floating task test\n\tNot done.", textDisplayFloating.getText());
		
		textInput.setText("done 1");
		buttonEnter.doClick();
		
		assertEquals("\nTask 1 is successfully labeled as done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("add floating task test 2");
		buttonEnter.doClick();

		assertEquals("\nSuccessfully added to task 2.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("2: floating task test 2\n\tNot done.", textDisplayFloating.getText());
		
		textInput.setText("view");
		buttonEnter.doClick();
		
		assertEquals("\n2: floating task test 2\n\tNot done.\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("2: floating task test 2\n\tNot done.", textDisplayFloating.getText());
	}
	
	@Test
	public void ViewNextTest() {
		textInput.setText("add next next by 2000 tml");
		buttonEnter.doClick();
		String formattedUpcomingTime = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2000")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedUpcomingTime + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("add next by 1800 tml");
		buttonEnter.doClick();
		formattedUpcomingTime = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1800")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 2.\n\tDeadline:" + formattedUpcomingTime + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("view next");
		buttonEnter.doClick();
		assertEquals(
				"\n2: next" +
						"\n\tEnd Time:" + formattedUpcomingTime + "\n\tNot done.\n", 
						textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void ViewOverdueTest() {
		Logic logic = new Logic("guiTest");
		Task task = new Task();
		task.setOpcode(OPCODE.ADD);
		task.setAddType(Types.ADDTYPE.DEADLINE);
		task.setDescription("overdue");
		task.setEndTime("201301012359");
		logic.executeTask(task);
		
		textInput.setText("view overdue");
		buttonEnter.doClick();
		assertEquals(
				"\n1: overdue" +
						"\n\tEnd Time: 2013 Jan 01 23:59\n\tNot done.\n", 
						textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		task = new Task();
		task.setOpcode(OPCODE.DELETE);
		task.setDeleteType(Types.DELETETYPE.ID);
		task.setTaskID("1");
		logic.executeTask(task);
		
		textInput.setText("view overdue");
		buttonEnter.doClick();
		assertEquals("\nNo tasks to display!\n", textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void ViewDateTest() {
		textInput.setText("add tmlTask1 by 1800 tml");
		buttonEnter.doClick();
		String formattedUpcomingTime1 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1800")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedUpcomingTime1 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("add tmlTask2 by 2000 tml");
		buttonEnter.doClick();
		String formattedUpcomingTime2 = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("2000")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 2.\n\tDeadline:" + formattedUpcomingTime2 + "\n",
				textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("view " + getTomorrowDate());
		buttonEnter.doClick();
		assertEquals(
				"\n1: tmlTask1" +
						"\n\tEnd Time:" + formattedUpcomingTime1 + "\n\tNot done.\n"
				+ "2: tmlTask2" +
						"\n\tEnd Time:" + formattedUpcomingTime2 + "\n\tNot done.\n", 
						textDisplayMain.getText());
		assertEquals("No tasks to display!", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}

	@Test
	public void ViewFromToDateTest() {
		textInput.setText("add todayTask by 2359 today");
		buttonEnter.doClick();
		String formattedTodayTime = LogicUtilities.getFormattedTime(getTodayDateForFormat("2359")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 1.\n\tDeadline:" + formattedTodayTime + "\n",
				textDisplayMain.getText());
		assertEquals("1: todayTask" +
				"\n\tEnd Time:" + formattedTodayTime + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("add tmlTask by 1800 tml");
		buttonEnter.doClick();
		String formattedTmlTime = LogicUtilities.getFormattedTime(getTomorrowDateForFormat("1800")).replaceAll(currentYear, "");
		assertEquals(
				"\nSuccessfully added to task 2.\n\tDeadline:" + formattedTmlTime + "\n",
				textDisplayMain.getText());
		assertEquals("1: todayTask" +
				"\n\tEnd Time:" + formattedTodayTime + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
		
		textInput.setText("view from " + getTodayDate() + " to " + getTomorrowDate());
		buttonEnter.doClick();
		assertEquals(
				"\n1: todayTask" +
						"\n\tEnd Time:" + formattedTodayTime + "\n\tNot done.\n"
				+ "2: tmlTask" +
						"\n\tEnd Time:" + formattedTmlTime + "\n\tNot done.\n", 
						textDisplayMain.getText());
		assertEquals("1: todayTask" +
				"\n\tEnd Time:" + formattedTodayTime + "\n\tNot done.", textDisplayUpcoming.getText());
		assertEquals("No tasks to display!", textDisplayFloating.getText());
	}
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\junit\ui\GUIBehaviorTest.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\api\Parser.java
	 */

/*
 *  This is the Parser API for WhatsUpNext
 */
package whatsupnext.parser.api;

import java.util.StringTokenizer;

import whatsupnext.parser.extractor.AddExtractor;
import whatsupnext.parser.extractor.DeleteExtractor;
import whatsupnext.parser.extractor.DoneExtractor;
import whatsupnext.parser.extractor.FreeExtractor;
import whatsupnext.parser.extractor.HelpExtractor;
import whatsupnext.parser.extractor.SearchExtractor;
import whatsupnext.parser.extractor.UpdateExtractor;
import whatsupnext.parser.extractor.ViewExtractor;
import whatsupnext.structure.enums.OPCODE;
import whatsupnext.structure.util.Task;

public class Parser {

	// Messages
	private final String MESSAGE_INVALID_OPCODE = "Unrecognized command type";
	
	//These are the aliases for opcode
	private final String[] ALIASES_ADD = {"add", "a"};
	private final String[] ALIASES_VIEW = {"view", "v", "list", "ls", "l"};
	private final String[] ALIASES_UPDATE = {"update", "u", "edit", "e", "modify", "m"};
	private final String[] ALIASES_DELETE = {"delete", "del", "d"};
	private final String[] ALIASES_SEARCH = {"search", "s", "find", "f"};
	private final String[] ALIASES_DONE = {"done"};
	private final String[] ALIASES_UNDO = {"undo"};
	private final String[] ALIASES_REDO = {"redo"};
	private final String[] ALIASES_FREE = {"free"};
	private final String[] ALIASES_HELP = {"help", "h", "?"};
	private final String[] ALIASES_EXIT = {"exit", "e", "quit", "q"};
	
	private String input;
	private Task task;
	
	public Parser(String inputCommand) {
		input = inputCommand;
		task = new Task();
	}
	
	/**
	 * Returns a Task object containing information extracted during parsing of the input
	 * @return the Task object
	 */
	public Task parseInput() {
		StringTokenizer tokenizedInput = new StringTokenizer(input);
		if (tokenizedInput.hasMoreTokens()){
			String operation = tokenizedInput.nextToken();
			task.setOpcode(determineOperation(operation));
			input = removeFirstWord(input);
			parseRemainingArguments();
		} else {
			task.setOpcode(OPCODE.INVALID);
		}
		assert(task.getOpCode() != null);
		return task;
	}

	private void parseRemainingArguments() {
		switch (task.getOpCode()) {
			case ADD:
				AddExtractor exAdd = new AddExtractor();
				exAdd.extract(task, input);
				break;
			case VIEW:
				ViewExtractor exView = new ViewExtractor();
				exView.extract(task, input);
				break;
			case UPDATE:
				UpdateExtractor exUpdate = new UpdateExtractor();
				exUpdate.extract(task, input);
				break;
			case DELETE:
				DeleteExtractor exDelete = new DeleteExtractor();
				exDelete.extract(task, input);
				break;
			case SEARCH:
				SearchExtractor exSearch = new SearchExtractor();
				exSearch.extract(task, input);
				break;
			case DONE:
				DoneExtractor exDone = new DoneExtractor();
				exDone.extract(task, input);
				break;
			case UNDO:
				break;
			case REDO:
				break;
			case FREE:
				FreeExtractor exFree = new FreeExtractor();
				exFree.extract(task, input);
				break;
			case HELP:
				HelpExtractor exHelp = new HelpExtractor();
				exHelp.extract(task, input);
				break;
			case EXIT:
				break;
			default:
				throw new IllegalArgumentException(MESSAGE_INVALID_OPCODE);
		}
	}

	private OPCODE determineOperation(String operation) {
		if (isInOperationAliases(operation, ALIASES_ADD)) {
			return OPCODE.ADD;
		} else if (isInOperationAliases(operation, ALIASES_VIEW)) {
			return OPCODE.VIEW;
		} else if (isInOperationAliases(operation, ALIASES_UPDATE)) {
			return OPCODE.UPDATE;
		} else if (isInOperationAliases(operation, ALIASES_DELETE)) {
			return OPCODE.DELETE;
		} else if (isInOperationAliases(operation, ALIASES_SEARCH)) {
			return OPCODE.SEARCH;
		} else if (isInOperationAliases(operation, ALIASES_DONE)) {
			return OPCODE.DONE;
		} else if (isInOperationAliases(operation, ALIASES_UNDO)) {
			return OPCODE.UNDO;
		} else if (isInOperationAliases(operation, ALIASES_REDO)) {
			return OPCODE.REDO;
		} else if (isInOperationAliases(operation, ALIASES_FREE)) {
			return OPCODE.FREE;
		}else if (isInOperationAliases(operation, ALIASES_HELP)) {
			return OPCODE.HELP;
		} else if (isInOperationAliases(operation, ALIASES_EXIT)) {
			return OPCODE.EXIT;
		} else {
			return OPCODE.INVALID;
		}
	}

	private boolean isInOperationAliases(String operation, String[] aliases) {
		for (String alias : aliases) {
			if (operation.equalsIgnoreCase(alias)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Removes the first word of a string
	 * @param userCommand the string to be manipulated
	 * @return remaining words of the string
	 */
	private String removeFirstWord(String userCommand) {
		String commandString;
		try {
			commandString = userCommand.trim().split("\\s+", 2)[1];
		} catch (ArrayIndexOutOfBoundsException e) {
			commandString = "";
		}
		return commandString;
	}
}
	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\api\Parser.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\Extractor.java
	 */

package whatsupnext.parser.extractor;

import whatsupnext.structure.util.Task;

public interface Extractor {
	
	/**
	 * Returns a string feedback on the status of extraction
	 * @param task A Task object to put in the extracted information
	 * @param input The string to perform extraction
	 * @return 
	 */
	void extract(Task task, String input);
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\Extractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\HelpExtractor.java
	 */

package whatsupnext.parser.extractor;

import whatsupnext.structure.util.Help;
import whatsupnext.structure.util.Task;

public class HelpExtractor {
	private final String MESSAGE_INVALID_ARGUMENT = "Invalid Argument.";
	
	public void extract(Task task, String input){
		if(input.isEmpty()) {
			task.setHelpMessage(Help.DEFAULT_HELP_MESSAGE);
		} else {
			String argument= Utility.getFirstWord(input);
			switch (argument.toLowerCase()) {	
				case "add":
					task.setHelpMessage(Help.ADD_HELP_MESSAGE);
					break;
				case "view":
					task.setHelpMessage(Help.VIEW_HELP_MESSAGE);
					break;
				case "update":
					task.setHelpMessage(Help.UPDATE_HELP_MESSAGE);
					break;
				case "delete":
					task.setHelpMessage(Help.DELETE_HELP_MESSAGE);
					break;
				case "search":
					task.setHelpMessage(Help.SEARCH_HELP_MESSAGE);
					break;
				case "free":
					task.setHelpMessage(Help.FREE_HELP_MESSAGE);
					break;					
				case "done":
					task.setHelpMessage(Help.DONE_HELP_MESSAGE);
					break;
				case "undo":
					task.setHelpMessage(Help.UNDO_HELP_MESSAGE);
					break;
				case "redo":
					task.setHelpMessage(Help.REDO_HELP_MESSAGE);
					break;
				case "exit":
					task.setHelpMessage(Help.EXIT_HELP_MESSAGE);
					break;
				case "time":
					task.setHelpMessage(Help.TIME_HELP_MESSAGE);
					break;
				default:
					throw new IllegalArgumentException(MESSAGE_INVALID_ARGUMENT);
			}
		}
	}
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\HelpExtractor.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\ParseDate.java
	 */

package whatsupnext.parser.extractor;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ParseDate {
	
	// These are the time and date formats
	private final String FORMAT_MINUTE = "HHmm";
	private final String FORMAT_TODAY = "yyyyMMdd";
	private final ArrayList<String> FORMATS_TIME = new ArrayList<String>(Arrays.asList("HHmm", "HH:mm",
																						"h:mm a", "h a"));
	private final ArrayList<String> FORMATS_DATE = new ArrayList<String>(Arrays.asList("ddMMyy", "ddMMyyyy", 
																						"dd/MM/yy", "dd/MM/yyyy", 
																						"dd-MM-yy", "dd-MM-yyyy",
																						"dd MMM yy", "dd MMM yyyy",
																						"dd MMMM yy", "dd MMMM yyyy"));
	
	//These are the aliases for day of week 
	private final ArrayList<String> ALIASES_TODAY = new ArrayList<String>(Arrays.asList("today"));
	private final ArrayList<String> ALIASES_TOMORROW = new ArrayList<String>(Arrays.asList("tomorrow", "tml", "tmr"));
	private final ArrayList<String> ALIASES_SUNDAY = new ArrayList<String>(Arrays.asList("sunday", "sun"));
	private final ArrayList<String> ALIASES_MONDAY = new ArrayList<String>(Arrays.asList("monday", "mon"));
	private final ArrayList<String> ALIASES_TUESDAY = new ArrayList<String>(Arrays.asList("tuesday", "tue"));
	private final ArrayList<String> ALIASES_WEDNESDAY = new ArrayList<String>(Arrays.asList("wednesday", "wed"));
	private final ArrayList<String> ALIASES_THURSDAY = new ArrayList<String>(Arrays.asList("thursday", "thu"));
	private final ArrayList<String> ALIASES_FRIDAY = new ArrayList<String>(Arrays.asList("friday", "fri"));
	private final ArrayList<String> ALIASES_SATURDAY = new ArrayList<String>(Arrays.asList("saturday", "sat"));
	
	//These indicate magic string/number
	private final String NOW = "now";
	private final String FIRST_MINUTE = "0000";
	private final String LAST_MINUTE = "2359";
	private final String SINGLE_QUOTE = "'";
	private final int DAYS_IN_WEEK = 7;
	
	private ArrayList<String> listOfTimeDateFormats;
	private ArrayList<String> listOfTimeDayFormats;
	private ArrayList<String> listOfAliasesDays;
	
	private boolean isParsingStartTime;
	
	private static Logger logger = Logger.getLogger("ParseDate");
	
	public ParseDate(){
		listOfTimeDateFormats = getTimeDateFormats();
		listOfAliasesDays = getAliasesDays();
		listOfTimeDayFormats = getTimeDayFormats();
		isParsingStartTime = false;
	}
	
	/**
	 * Returns a 12-length formatted date string of the input 
	 * @return In format of: yyyyMMddHHmm
	 */
	public String parseInput(String input) {
		String formattedDate = "";
		input = input.toLowerCase();
		
		if(input.equalsIgnoreCase(NOW)) {
			formattedDate = getCurrentTime();
		}
		if(formattedDate.isEmpty()) {
			formattedDate = parseTimeDateFormats(input);
		}
		if(formattedDate.isEmpty()) {
			formattedDate = parseTimeDayFormats(input);
		} 
		if(formattedDate.length() != 12) {
			formattedDate = "";
		}
		assert (formattedDate.isEmpty() || formattedDate.length() == 12);
		if(formattedDate.length() == 12) {
			logger.log(Level.INFO, "ParseDate Success!: " + input + " to " + formattedDate);
		} else {
			logger.log(Level.INFO, "ParseDate Failure!: " + input);
		}
		return formattedDate;
	}
	
	/**
	 * Set to parse input as a start time.
	 */
	public void setParsingStartTime(boolean isParsingStartTime) {
		this.isParsingStartTime = isParsingStartTime;
	}
	
	/**
	 * Returns a 12-length string of current time 
	 * @return In format of: yyyyMMddHHmm
	 */
	public String getCurrentTime() {
		Calendar cal = Calendar.getInstance();
		String formattedDate = formatDate(cal);
		assert (formattedDate.length() == 12);
		return formattedDate; 
	}
	
	/**
	 * Returns a 8-length string of today date 
	 * @return In format of: yyyyMMdd
	 */
	public String getTodayDate() {
		Calendar cal = Calendar.getInstance();
		int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth);
		assert (year >= 1000 && year <= 9999 );
		assert (twoDigitMonth.length() == 2);
		assert (twoDigitDayOfMonth.length() == 2);
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	/**
	 * Returns a 8-length string of provided Calendar object
	 * @param cal Calendar to be formatted
	 * @return In format of: yyyyMMdd
	 */
	public String getDateString(Calendar cal) {
		int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
        String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth);
		assert (year >= 1000 && year <= 9999 );
		assert (twoDigitMonth.length() == 2);
		assert (twoDigitDayOfMonth.length() == 2);
		return year + twoDigitMonth + twoDigitDayOfMonth;
	}
	
	private ArrayList<String> getTimeDateFormats() {
		ArrayList<String> allFormats = new ArrayList<String>();
		for (String time : FORMATS_TIME) {
			for (String date : FORMATS_DATE) {
				allFormats.add(time + " " + date);
			}
		}
		for (String date : FORMATS_DATE) {
			for (String time : FORMATS_TIME) {
				allFormats.add(date + " " + time);
			}
		}
		for (String time : FORMATS_TIME) {
			allFormats.add(time);
		}
		for (String date : FORMATS_DATE) {
			allFormats.add(date);
		}
		return allFormats;
	}
	
	private ArrayList<String> getAliasesDays(){
		ArrayList<String> allAliasesDays = new ArrayList<String>();
		allAliasesDays.addAll(ALIASES_TODAY);
		allAliasesDays.addAll(ALIASES_TOMORROW);
		allAliasesDays.addAll(ALIASES_SUNDAY);
		allAliasesDays.addAll(ALIASES_MONDAY);
		allAliasesDays.addAll(ALIASES_TUESDAY);
		allAliasesDays.addAll(ALIASES_WEDNESDAY);
		allAliasesDays.addAll(ALIASES_THURSDAY);
		allAliasesDays.addAll(ALIASES_FRIDAY);
		allAliasesDays.addAll(ALIASES_SATURDAY);
		
		return allAliasesDays;
	}
	
	private ArrayList<String> getTimeDayFormats() {
		ArrayList<String> allFormats = new ArrayList<String>();
		for (String time : FORMATS_TIME) {
			for (String day : listOfAliasesDays){
				allFormats.add(time + " " + SINGLE_QUOTE + day + SINGLE_QUOTE);
			}
		}
		for (String day : listOfAliasesDays){
			for (String time : FORMATS_TIME) {
				allFormats.add(SINGLE_QUOTE + day + SINGLE_QUOTE + " " + time);
			}
		}
		
		return allFormats;
	}
	
	private String parseTimeDateFormats(String input) {
		String formattedDate = "";
		String formattedInput = "";
		SimpleDateFormat formatter = null;
		for (String format : listOfTimeDateFormats) {
			try {
				formattedInput = input;
				formatter = new SimpleDateFormat(format);
				if (FORMATS_TIME.contains(format)) {
					formatter = new SimpleDateFormat(format + " " + FORMAT_TODAY);
					formattedInput = formattedInput + " " + getTodayDate();
				}
				if (FORMATS_DATE.contains(format)) {
					formatter = new SimpleDateFormat(format + " " + FORMAT_MINUTE);
					if(isParsingStartTime) {
						formattedInput = formattedInput + " " + FIRST_MINUTE;
					} else {
						formattedInput = formattedInput + " " + LAST_MINUTE;
					}
				}
				formatter.setLenient(false);
				Calendar cal = Calendar.getInstance();
				cal.setTime(formatter.parse(formattedInput));
				formattedDate = formatDate(cal);
				break;
			} catch (ParseException e) {
				//Do nothing. Continue with other formats
			}
		}

		return formattedDate;
	}
	
	private String parseTimeDayFormats(String input) {
		String formattedDate = "";
		String formattedInput = "";
		SimpleDateFormat formatter = null;
		for (String format : listOfTimeDayFormats) {
			try {
				formattedInput = input + " " + getTodayDate();
				formatter = new SimpleDateFormat(format + " " + FORMAT_TODAY);
				if (listOfAliasesDays.contains(input)){
					formatter = new SimpleDateFormat(FORMAT_TODAY + " " + FORMAT_MINUTE);
					if(isParsingStartTime) {
						formattedInput = getTodayDate() + " " + FIRST_MINUTE;
					} else {
						formattedInput = getTodayDate() + " " + LAST_MINUTE;
					}					
				}
				formatter.setLenient(false);
				Calendar cal = Calendar.getInstance();
				cal.setTime(formatter.parse(formattedInput));
				cal = setNewDay(cal, input);
				formattedDate = formatDate(cal);
				break;
			} catch (ParseException e) {
				//Do nothing. Continue with other formats
			}
		}
		
		return formattedDate;
	}
	
	/**
	 * Returns an future Calendar which has its date forwarded based on provided day of week
	 * @param cal Calendar to be updated
	 * @param input the input that contains the Day of Week
	 * @return the updated Calendar
	 */
	private Calendar setNewDay(Calendar cal, String input){
		int numOfDay = 0;
		for (String today : ALIASES_TODAY) {
			if(input.contains(today)) {
				cal.add(Calendar.DAY_OF_YEAR, 0);
				return cal;
			}
		}
		for (String tomorrow : ALIASES_TOMORROW) {
			if(input.contains(tomorrow)) {
				cal.add(Calendar.DAY_OF_YEAR, 1);
				return cal;
			}
		}
		for (String sunday : ALIASES_SUNDAY) {
			if(input.contains(sunday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.SUNDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		for (String monday : ALIASES_MONDAY) {
			if(input.contains(monday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.MONDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		for (String tuesday : ALIASES_TUESDAY) {
			if(input.contains(tuesday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.TUESDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		for (String wednesday : ALIASES_WEDNESDAY) {
			if(input.contains(wednesday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.WEDNESDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		for (String thursday : ALIASES_THURSDAY) {
			if(input.contains(thursday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.THURSDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		for (String friday : ALIASES_FRIDAY) {
			if(input.contains(friday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.FRIDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		for (String saturday : ALIASES_SATURDAY) {
			if(input.contains(saturday)) {
				numOfDay = getNumOfDay(cal.get(Calendar.DAY_OF_WEEK), Calendar.SATURDAY);
				cal.add(Calendar.DAY_OF_YEAR, numOfDay);
				return cal;
			}
		}
		
		return cal;
	}
	
	/**
	 * Returns the number of days from the provided current day of week to the expected day of week
	 * @param currentDayOfWeek the integer value of current day of week
	 * @param expectedDayOfWeek the integer value of expected day of week
	 * @return the number of days to reach expected day of week
	 */
	private int getNumOfDay(int currentDayOfWeek, int expectedDayOfWeek) {
		int numOfDay = 0;
		int newDay = 0;
		for(int i = 1; i <= DAYS_IN_WEEK; i++) {
			newDay = currentDayOfWeek + i; 
			if(newDay > DAYS_IN_WEEK) {
				newDay = (currentDayOfWeek + i) % DAYS_IN_WEEK;
			}
			if (newDay == expectedDayOfWeek) {
				numOfDay = i;
				break;
			}
		}
		
		return numOfDay;
	}
	
	/**
	 * Returns a 12-length string based on provided calendar
	 * @param cal Calendar to be formatted 
	 * @return In format of: yyyyMMddHHmm
	 */
	private String formatDate(Calendar cal) {
		int year = cal.get(Calendar.YEAR);
		int month = cal.get(Calendar.MONTH) + 1;
		int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);
		int hour = cal.get(Calendar.HOUR_OF_DAY);
		int minute = cal.get(Calendar.MINUTE);
		String twoDigitMonth = convertToTwoDigits(month);
		String twoDigitDayOfMonth = convertToTwoDigits(dayOfMonth);
		String twoDigitHour = convertToTwoDigits(hour);
		String twoDigitMinute = convertToTwoDigits(minute);

		return year + twoDigitMonth + twoDigitDayOfMonth + twoDigitHour + twoDigitMinute; 
	}
	
	private String convertToTwoDigits(int value) {
		if(value < 10) {
			return "0" + value;
		} else {
			return "" + value;
		}
	}

}
	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\parser\extractor\ParseDate.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\structure\enums\OPCODE.java
	 */

package whatsupnext.structure.enums;

public enum OPCODE {
	ADD, VIEW, UPDATE, DELETE, SEARCH, DONE, UNDO, REDO, FREE, HELP, INVALID, EXIT
}


	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\structure\enums\OPCODE.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\structure\util\Help.java
	 */

package whatsupnext.structure.util;

public class Help {
	
	private static final String INDENT = "\t";
	private static final String NEWLINE = "\n";
	
	public static final String DEFAULT_HELP_MESSAGE = "Supported Commands:"
			+ NEWLINE + "add" + INDENT + "Add a task by with description"
			+ NEWLINE + INDENT + "only or append it with a deadline"
			+ NEWLINE + INDENT + "or a time period."
			+ NEWLINE + "view" + INDENT + "Display the upcoming task or the"
			+ NEWLINE + INDENT + "tasks for the day. A time frame " 
			+ NEWLINE + INDENT + "can be specified too."
			+ NEWLINE + "update" + INDENT + "Update the description, deadline,"
			+ NEWLINE + INDENT + "start or end time of a task."
			+ NEWLINE + "delete" + INDENT + "Delete by id, date, deadline, or"
			+ NEWLINE + INDENT + "time frame."
			+ NEWLINE + "search" + INDENT + "Search for a task by its keyword."
			+ NEWLINE + "free" + INDENT + "Find free time slots of certain "
			+ NEWLINE + INDENT + "duration today, or by specifying"
			+ NEWLINE + INDENT + "end_time, date or time frame."
			+ NEWLINE + "done" + INDENT + "Label a task as done."
			+ NEWLINE + "undo" + INDENT + "Undo most recent add/update/delete."
			+ NEWLINE + "redo" + INDENT + "Redo the most recent undo."
			+ NEWLINE + "exit" + INDENT + "Close WhatsUpNext."
			+ NEWLINE
			+ NEWLINE + "Help aliases supported:"
			+ NEWLINE + "\'h\', \'?\'"
			+ NEWLINE
			+ NEWLINE + "Type \"help <command>\" to find out more."
			+ NEWLINE + "Type \"help time\" to see time/date formats.";
	
	public static final String ADD_HELP_MESSAGE = "add" + INDENT + "Add a task by with description only"
			+ NEWLINE + INDENT + "or append it with a deadline or time"
			+ NEWLINE + INDENT + "period."
			+ NEWLINE
			+ NEWLINE + "Formats supported:"
			+ NEWLINE + "add [task]"
			+ NEWLINE + "add [task] by [end_time]" 
			+ NEWLINE + "add [task] from [start_time] to [end_time]"
			+ NEWLINE
			+ NEWLINE + "Aliases supported:"
			+ NEWLINE + "\'a\'";
	
	public static final String VIEW_HELP_MESSAGE = "view" + INDENT + "Display the upcoming task or the"
			+ NEWLINE + INDENT + "tasks for the day. A time frame can" 
			+ NEWLINE + INDENT + "be specified too."
			+ NEWLINE
			+ NEWLINE + "Formats supported:"
			+ NEWLINE + "view all"
			+ NEWLINE + "view next"
			+ NEWLINE + "view [day|date]"
			+ NEWLINE + "view from [start_time] to [end_time]"
			+ NEWLINE
			+ NEWLINE + "Aliases supported:"
			+ NEWLINE + "\'v\', \'list\', \'ls\', \'l\'";
	
	public static final String UPDATE_HELP_MESSAGE =  "update" + INDENT + "Update the description, deadline,"
			+ NEWLINE + INDENT + "start or end time of a task."
			+ NEWLINE
			+ NEWLINE + "Formats supported:"
			+ NEWLINE + "update [task_id] [new_description]"
			+ NEWLINE + "update [task_id] by [end_time]"
			+ NEWLINE + "update [task_id] from [start_time] to [end_time]"
			+ NEWLINE
			+ NEWLINE + "Aliases supported:"
			+ NEWLINE + "\'u\', \'edit\', \'e\', \'modify\', \'m\'";
			
	public static final String DELETE_HELP_MESSAGE = "delete" + INDENT + "Delete by id, date, deadline, or"
			+ NEWLINE + INDENT + "time frame. "
			+ NEWLINE + INDENT + "Can also delete done tasks or tasks"
			+ NEWLINE + INDENT + "that passed deadline"
			+ NEWLINE
			+ NEWLINE + "Formats supported:"
			+ NEWLINE + "delete [task_id]"
			+ NEWLINE + "delete deadline"
			+ NEWLINE + "delete done"
			+ NEWLINE + "delete [date]"
			+ NEWLINE + "delete from [start_time] to [end_time]"
			+ NEWLINE
			+ NEWLINE + "Aliases supported:"
			+ NEWLINE + "\'del\', \'d\'";

	public static final String SEARCH_HELP_MESSAGE = "search" + INDENT + "Search for a task by its keyword."
			+ NEWLINE
			+ NEWLINE + "Formats supported:" 
			+ NEWLINE + "search [keywords]"
			+ NEWLINE
			+ NEWLINE + "Aliases supported:"
			+ NEWLINE + "\'s\', \'find\', \'f\'";
	
	public static final String FREE_HELP_MESSAGE = "free" + INDENT + "find free slots of certain duration"
			+ NEWLINE + INDENT + "today or by specifying an end_time, "
			+ NEWLINE + INDENT + "date or time frame."
			+ NEWLINE
			+ NEWLINE + "Formats supported:"
			+ NEWLINE + "free [duration]"
			+ NEWLINE + "free [duration] by [end_time]"
			+ NEWLINE + "free [duration] on [date]"
			+ NEWLINE + "free [duration] from [start_time] to [end_time]"
			+ NEWLINE
			+ NEWLINE + "NOTE: [duration] is in number of hours" 
			+ NEWLINE + "      Time slots during general sleeping time "
			+ NEWLINE + "      <10 pm to 6 am> would not be returned";
	
	public static final String DONE_HELP_MESSAGE = "done" + INDENT + "Label a task as done."
			+ NEWLINE
			+ NEWLINE + "Formats supported:"
			+ NEWLINE + "done [task_id]";
	
	public static final String UNDO_HELP_MESSAGE = "undo" + INDENT + "Undo most recent add/update/delete.";
	
	public static final String REDO_HELP_MESSAGE = "redo" + INDENT + "Redo the most recent undo.";
	
	public static final String EXIT_HELP_MESSAGE = "exit" + INDENT + "Close WhatsUpNext."
			+ NEWLINE
			+ NEWLINE + "Aliases supported:"
			+ NEWLINE + "\'e\', \'quit\', \'q\'";;
	
	public static final String TIME_HELP_MESSAGE = "Time formats supported:"
			+ NEWLINE + "24-hour clock" + INDENT + "\'09:00\', \'2359\'" 
			+ NEWLINE + "12-hour clock" + INDENT + "\'9:00 am, \'11 pm\'"
			+ NEWLINE
			+ NEWLINE + "Date formats supported:"
			+ NEWLINE + "DayMonthYear  " + INDENT + "\'021114\',"
			+ NEWLINE + INDENT + INDENT + "\'31102013\'"
			+ NEWLINE + "Day/Month/Year" + INDENT + "\'02/11/14\',"
			+ NEWLINE + INDENT + INDENT + "\'31/10/2013\'"
			+ NEWLINE + "Day-Month-Year" + INDENT + "\'02-11-14\',"
			+ NEWLINE + INDENT + INDENT + "\'31-10-2013\'"
			+ NEWLINE + "Day Month Year" + INDENT + "\'02 nov 14\',"
			+ NEWLINE + INDENT + INDENT + "\'02 November 2013\'"
			+ NEWLINE
			+ NEWLINE + "Special formats supported:"
			+ NEWLINE + "Day of Week" + INDENT + "\'monday\', \'mon\'"
			+ NEWLINE + "Today date" + INDENT + INDENT + "\'today\'"
			+ NEWLINE + "Tomorrow date" + INDENT + "\'tomorrow\', \'tml\',\'tmr\'"
			+ NEWLINE + "Current Time" + INDENT + "\'now\'"
			+ NEWLINE
			+ NEWLINE + "Valid examples:"
			+ NEWLINE + "\'0000 010114\', \'31/12/2013 23:59\'"
			+ NEWLINE + "\'7:30 am sunday\', \'tml 12 pm\'"
			+ NEWLINE + "\'0930 10-11-14\', \'11:30 am today\'"
			+ NEWLINE +  "\'now\'"
			+ NEWLINE
			+ NEWLINE + "Things to note:"
			+ NEWLINE + "-Day of week is referring to the upcoming day of week."
			+ NEWLINE + "-If you have only specify the time, today date will be automatically assigned to it."
			+ NEWLINE + "-If you have only specify the date, either time 0000 for start time "
					+ "or time 2359 for end time will be automatically assigned to it.";
	
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\structure\util\Help.java





	/**
	 * origin: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\structure\util\Task.java
	 */

package whatsupnext.structure.util;

import java.util.Arrays;

import whatsupnext.structure.enums.OPCODE;
import whatsupnext.structure.enums.Types.ADDTYPE;
import whatsupnext.structure.enums.Types.DELETETYPE;
import whatsupnext.structure.enums.Types.FREETYPE;
import whatsupnext.structure.enums.Types.UPDATETYPE;
import whatsupnext.structure.enums.Types.VIEWTYPE;

public class Task {

	private static final int OPERAND_SIZE = 4;
	private static final int INDEX_FOR_TASK_ID = 0;
	private static final int INDEX_FOR_DESCRIPTION = 1;
	private static final int INDEX_FOR_HELP_MESSAGE = 1;
	private static final int INDEX_FOR_SEARCH_KEYWORD = 1;
	private static final int INDEX_FOR_START_TIME = 2;
	private static final int INDEX_FOR_END_TIME = 3;
	
	private OPCODE opcode;
	private ADDTYPE addType;
	private VIEWTYPE viewType;
	private UPDATETYPE updateType;
	private DELETETYPE deleteType;
	private FREETYPE freeType;
	private String[] operand;
	private boolean isDone;

	public Task() {
		setOpcode(null);
		setAddType(null);
		setViewType(null);
		setUpdateType(null);
		setDeleteType(null);
		operand = new String[OPERAND_SIZE];
		Arrays.fill(operand, "");
	}

	public OPCODE getOpCode() {
		return opcode;
	}

	public void setOpcode(OPCODE opcode) {
		this.opcode = opcode;
	}
	
	public ADDTYPE getAddType() {
		return addType;
	}
	
	public void setAddType(ADDTYPE addType) {
		this.addType = addType;
	}
	
	public VIEWTYPE getViewType() {
		return viewType;
	}
	
	public void setViewType(VIEWTYPE viewType) {
		this.viewType = viewType;
	}
	
	public UPDATETYPE getUpdateType() {
		return updateType;
	}
	
	public void setUpdateType(UPDATETYPE updateType) {
		this.updateType = updateType;
	}
	
	public DELETETYPE getDeleteType() {
		return deleteType;
	}
	
	public void setDeleteType(DELETETYPE deleteType) {
		this.deleteType = deleteType;
	}
	
	public String getTaskID() {
		return operand[INDEX_FOR_TASK_ID];
	}
	
	public void setTaskID(String taskID) {
		operand[INDEX_FOR_TASK_ID] = taskID;
	}
	
	public String getDescription() {
		return operand[INDEX_FOR_DESCRIPTION];
	}
	
	public void setDescription(String description) {
		operand[INDEX_FOR_DESCRIPTION] = description;
	}
	
	public String getHelpMessage() {
		return operand[INDEX_FOR_HELP_MESSAGE];
	}
	
	public void setHelpMessage(String message) {
		operand[INDEX_FOR_HELP_MESSAGE] = message;
	}
	
	public String getSearchKeyword() {
		return operand[INDEX_FOR_SEARCH_KEYWORD];
	}
	
	public void setSearchKeyword(String keyword) {
		operand[INDEX_FOR_SEARCH_KEYWORD] = keyword;
	}
	
	public String getStartTime() {
		return operand[INDEX_FOR_START_TIME];
	}
	
	public void setStartTime(String startTime) {
		operand[INDEX_FOR_START_TIME] = startTime;
	}
	
	public String getEndTime() {
		return operand[INDEX_FOR_END_TIME];
	}
	
	public void setEndTime(String endTime) {
		operand[INDEX_FOR_END_TIME] = endTime;
	}
	
	public boolean getDone() {
		return isDone;
	}
	
	public void setDone(boolean isDone) {
		this.isDone = isDone;
	}
	
	// Function to check the equality of any two task objects on the basis of taskID, description, startTime, endTime
	public boolean equals(Object o) {
		if (o instanceof Task && ((Task)o).getTaskID().equals(getTaskID()) 
				&& ((Task)o).getDescription().equals(getDescription())
				&& ((Task) o).getStartTime().equals(getStartTime())
				&& ((Task) o).getEndTime().equals(getEndTime())) {
			return true;
		}
		return false;
	}

	public FREETYPE getFreeType() {
		return freeType;	
	}

	public void setFreeType(FREETYPE freeType) {
		this.freeType = freeType;
	}
}

	// End of segment: C:\Users\KJX\git\cs2103aug2014-f09-1j\src\whatsupnext\structure\util\Task.java





